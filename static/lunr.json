[
    {
        "uri": "",
        "content": "\n\ntitle: command ab\ndate: 2021-10-19T13:41:27+08:00\ndraft: true\ntags: [\"linux\"]\n\nab\n\nab参数翻译如下：-n 即requests，用于指定压力测试/总请求数。\n-c 即concurrency，用于指定压力测试的并发数。\n-t 即timelimit，测试执行最大秒数，它可以让测试限制在一个固定的总时间以内，默认值为50000。\n-s 即timeout，请求最大等待时长，默认30s\n-b 即windowsize，TCP发送/接收的缓冲大小(单位：字节)。\n-p 即postfile，发送POST请求时需要上传的文件，文件格式如\"p1=1&p2=2\"。使用方法是 -p 123.txt 。 （配合-T）\n-u 即putfile，发送PUT请求时需要上传的文件。（配合-T）\n-T 即content-type，用于设置Content-Type请求头信息，如 -T \"application/x-www-form-urlencoded”，默认值为text/plain。（配合-p）\n-v 即verbosity，设置显示信息的详细程度 – 4或更大值会显示头信息， 3或更大值可以显示响应代码(404, 200等), 2或更大值可以显示警告和其他信息。\n-w 以HTML表格形式打印结果。\n-i 使用HEAD请求代替GET请求。\n-x 插入字符串作为table标签的属性。\n-y 插入字符串作为tr标签的属性。\n-z 插入字符串作为td标签的属性。\n-C 添加cookie信息，例如：\"Apache=1234\"。此参数可以重复，用逗号分割。提示：可以借助session实现原理传递 JSESSIONID参数， 实现保持会话的功能，如-C \"c1=1234,c2=2,c3=3, JSESSIONID=FF056CD16DA9D71CB131C1D56F0319F8\"。\n-H 添加任意的请求头，例如：\"Accept-Encoding: gzip\"，请求头将会添加在现有的多个请求头之后(可以重复该参数选项以添加多个)。\n-A 添加一个基本的网络认证信息，用户名和密码之间用英文冒号隔开。\n-P 添加一个基本的代理认证信息，用户名和密码之间用英文冒号隔开。如-P proxy-auth-username:password\n-X 指定使用的代理服务器和端口号，例如:\"126.10.10.3:88\"。\n-V 显示版本号并退出。\n-k 使用HTTP的KeepAlive特性。\n-d 不显示百分比。\n-S 不显示预估和警告信息。\n-q 超过150个请求后不显示进度\n-l 接受可变文档长度（用于动态页面）\n-g filename 输出结果信息到gnuplot格式的文件中。\n-e filename 输出结果信息到CSV格式的文件中。\n-r 指定接收到错误信息时不退出程序。\n-m method 方法名\n-h 帮助\n\n> ab -n 10000 -c 50 -C ww_token=4e82e7102baec028586a05c512e9b969 -p \"put.txt\" -T \"multipart/form-data; boundary=----WebKitFormBoundaryCICCZksMPABLeATX\"  https://voice-maker-pre.mobvoi.com/apis/tts-web-api/v1/articles/426687\n",
        "tags": []
    },
    {
        "uri": "/posts/2021/09/git-submodule/",
        "title": "git submodule 使用方法",
        "content": "\nsubmodule\n\n平时我们在管理项目的时候都是用git来进行管理，git管理很方便，但是一旦项目越来越大，单个git仓库管理起来就没有那么方便了\n这个时候我们就可以使用git的另一个工具submodule来管理我们的项目\n\nsubmodule 是用来管理主项目和子项目之间的关系。\n\n使用\n\ngit submodule add\n\n此时主项目中会多出一个文件.gitmodules，此文件是用来管理子模块的\n\n以此博客为例\n\n[submodule \"themes/LoveIt\"]\n\tpath = themes/LoveIt\n\turl = https://github.com/dillonzq/LoveIt.git\n\n安装\n\n平时我们clone项目都是使用git clone xxx下载项目，如果项目中有子模块，这种方式就不能下载下来了\n\n如果希望子模块代码也获取到，一种方式是在克隆主项目的时候带上参数 --recurse-submodules，这样会递归地将项目中所有子模块的代码拉取。\n\n另一种方式\n\ngit submodule init && git submodule update\n\n更新所有模块\n\ngit submodule foreach 'git pull origin master'\n\ngit submodule update --init --recursive --remote\n\n单独更新一个子模块\n\ngit submodule update --init --remote a/submodule/path\n\n删除某个子模块\n\ngit submodule deinit project-sub-1\n\ngit rm project-sub-1\n\nissues\n\n1.版本跟踪里出现git submodule commit xxxxx错误\n\n解决方法\n\n> git submodule update\n",
        "tags": [
            "git"
        ]
    },
    {
        "uri": "/posts/2021/09/usage/",
        "title": "git 使用方法",
        "content": "\ngit使用手册\n\ntrack\n\ngit branch --track master origin/main\n\n等价于\n\ngit branch --set-upstream-to=origin/main master\n\n其中--set-upstream-to 和 -u等价\n\ngit branch -u origin/main master\n\n跟踪本地master分支到远程的main分支\n",
        "tags": [
            "git"
        ]
    },
    {
        "uri": "",
        "content": "\n\n  \n    \n\n    \n    Geometry Service: Relation\n\n    \n\n    \n      html,\n      body,\n      #mapDiv {\n        height: 100%;\n        margin: 0;\n        padding: 0;\n        width: 100%;\n      }\n      #info {\n        bottom: 20px;\n        color: #444;\n        height: auto;\n        font-family: arial;\n        left: 20px;\n        margin: 5px;\n        padding: 10px;\n        position: absolute;\n        text-align: left;\n        width: 200px;\n        z-index: 40;\n      }\n      .label {\n        display: inline-block;\n        width: 4em;\n      }\n    \n\n    \n    \n      var map;\n\n      require([\n        \"dojo/dom\",\n        \"dojo/_base/array\",\n        \"dojo/promise/all\",\n        \"dojo/json\",\n\n        \"esri/map\",\n        \"esri/domUtils\",\n        \"esri/graphic\",\n        \"esri/graphicsUtils\",\n        \"esri/geometry/Point\",\n        \"esri/tasks/GeometryService\",\n        \"esri/tasks/Geoprocessor\",\n        \"esri/tasks/FeatureSet\",\n        \"esri/tasks/RelationParameters\",\n        \"esri/Color\",\n        \"esri/symbols/SimpleLineSymbol\",\n        \"esri/symbols/SimpleMarkerSymbol\",\n        \"esri/symbols/SimpleFillSymbol\",\n        \"esri/request\",\n        \"dojo/domReady!\",\n      ], function (\n        dom,\n        array,\n        all,\n        JSON,\n\n        Map,\n        domUtils,\n        Graphic,\n        graphicsUtils,\n        Point,\n        GeometryService,\n        Geoprocessor,\n        FeatureSet,\n        RelationParameters,\n        Color,\n        SimpleLineSymbol,\n        SimpleMarkerSymbol,\n        SimpleFillSymbol,\n        esriRequest\n      ) {\n        var geoprocessor, geometryService, geometries, baseGraphics;\n\n        map = new esri.Map(\"mapDiv\", {\n          basemap: \"osm\",\n          center: [-117.185, 34.052],\n          zoom: 13,\n        });\n        map.on(\"click\", mapClicked);\n\n        geometryService = new GeometryService(\n          \"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Utilities/Geometry/GeometryServer\"\n        );\n        geoprocessor = new Geoprocessor(\n          \"https://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Network/ESRI_DriveTime_US/GPServer/CreateDriveTimePolygons\"\n        );\n        geoprocessor.setOutSpatialReference({\n          wkid: 4326,\n        });\n\n        function mapClicked(evt) {\n          geometries = [];\n          map.graphics.clear();\n\n          // add a simple marker graphic at the location where the user clicked on the map.\n          var pointSymbol = new SimpleMarkerSymbol(\n            SimpleMarkerSymbol.STYLE_CROSS,\n            22,\n            new SimpleLineSymbol(\n              SimpleLineSymbol.STYLE_SOLID,\n              new Color([0, 128, 0]),\n              4\n            )\n          );\n\n          var clickPointGraphic = new Graphic(evt.mapPoint, pointSymbol);\n          map.graphics.add(clickPointGraphic);\n\n          // use promise/all to monitor when place search and drive time calculation finish\n          all({\n            poiSearch: executeLocalSearch(clickPointGraphic),\n            driveTimes: getDriveTimePolygon(clickPointGraphic),\n          }).then(relateGeometries);\n        }\n\n        function executeLocalSearch(graphic) {\n          // find (up to) 20 pizza restaurants within a the map's current extent\n          var params = {\n            text: \"pizza\",\n            location: JSON.stringify(graphic.geometry.toJson()),\n            bbox: JSON.stringify(map.extent.toJson()),\n            maxLocations: 20,\n            f: \"json\",\n          };\n\n          return esriRequest({\n            url: \"//geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/find\",\n            content: params,\n            callbackParamName: \"callback\",\n          });\n        }\n\n        function showLocations(response) {\n          // create a symbol (Red Square) for pizza restaurants\n          var pointSymbol = new SimpleMarkerSymbol(\n            SimpleMarkerSymbol.STYLE_SQUARE,\n            6,\n            new SimpleLineSymbol(\n              SimpleLineSymbol.STYLE_SOLID,\n              new Color([0, 0, 0]),\n              1\n            ),\n            new Color([255, 0, 0])\n          );\n\n          // add the pizza restaurants to the map\n          var results = response.locations;\n          baseGraphics = array.map(results, function (r) {\n            var graphic = new Graphic(r.feature);\n            graphic.setSymbol(pointSymbol);\n            return map.graphics.add(graphic);\n          });\n        }\n\n        function getDriveTimePolygon(graphic) {\n          // the graphic representing the selected location is passed onto the GP Task\n          var featureSet = new FeatureSet();\n          featureSet.features = [graphic];\n\n          var params = {\n            Input_Location: featureSet,\n            Drive_Times: 3,\n          };\n          return geoprocessor.execute(params);\n        }\n\n        function showDriveTime(results, messages) {\n          var feature = results[0].value.features[0];\n\n          // add the drive time polygon to the map\n          var polySymbolRed = new SimpleFillSymbol(\n            SimpleLineSymbol.STYLE_SOLID,\n            new SimpleLineSymbol(\n              SimpleLineSymbol.STYLE_SOLID,\n              new Color([0, 0, 0, 1]),\n              1\n            ),\n            new Color([255, 0, 0, 0.2])\n          );\n          feature.setSymbol(polySymbolRed);\n          map.graphics.add(feature);\n        }\n\n        function relateGeometries(results) {\n          // check that both requests completed successfully\n          if (!results.poiSearch || !results.driveTimes) {\n            alert(\"Unable to compute point in polygon.\");\n          }\n          showDriveTime(results.driveTimes);\n          showLocations(results.poiSearch);\n          console.log(\"baseGraphics\", baseGraphics);\n          var relationParams = new RelationParameters();\n          relationParams.geometries1 =\n            graphicsUtils.getGeometries(baseGraphics);\n          relationParams.geometries2 = graphicsUtils.getGeometries(\n            results.driveTimes[0].value.features\n          );\n          relationParams.relation = RelationParameters.SPATIAL_REL_WITHIN;\n\n          geometryService.relation(relationParams).then(addRelateResultsToMap);\n          // alternatively, could use polygon.contains instead of using the geometry service\n        }\n\n        function addRelateResultsToMap(relations) {\n          console.log(\"add relate results\", relations);\n          // create a Green Square symbol\n          var symbol = new SimpleMarkerSymbol(\n            SimpleMarkerSymbol.STYLE_SQUARE,\n            8,\n            new SimpleLineSymbol(\n              SimpleLineSymbol.STYLE_SOLID,\n              new Color([0, 0, 0]),\n              1\n            ),\n            new Color([0, 255, 0])\n          );\n          // highlight the pizza places that satisfy the spatial relation (WITHIN) against the 3-minute drive time polygon\n          array.forEach(relations, function (relation) {\n            baseGraphics[relation.geometry1Index]\n              .setSymbol(symbol)\n              .getDojoShape()\n              .moveToFront();\n          });\n        }\n      });\n    \n  \n\n  \n    \n    \n      Click on the map to show Pizza restaurants that are within 3 minute drive\n      time.\n    \n  \n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "function classNames() {\n  let classes = [];\n\n  for (let i = 0; i < arguments.length; i++) {\n    if (!arguments[i]) {\n      continue;\n    }\n\n    const arg = arguments[i];\n\n    if (typeof arg === \"string\" || typeof arg === \"number\") {\n      // 直接插入\n      classes.push(arg);\n    } else if (Array.isArray(arg)) {\n      // 子项是数组\n      arg.length && classes.push(classNames.call(null, arg));\n    } else if (typeof arg === \"object\") {\n      // 判断是不是object, 是就进行遍历\n      if (arg.toString() === Object.prototype.toString()) {\n        for (let key in arg) {\n          if (arg[key]) {\n            classes.push(arg[key]);\n          }\n        }\n      } else {\n        // 不是object\n        classes.push(arg.toString());\n      }\n    }\n  }\n\n  return classes.join(\" \");\n}\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n\n    \n    \n    \n    Document\n\n\n\n\n    \n        \n            1\n            2\n            3\n            4\n            5\n            6\n        \n    \n\n\n    \n\n        function log (data) {\n            console.log('data :',data)\n        }\n\n        var container = document.querySelector(\".container\")\n\n        var tree = document.createTreeWalker(container, 1)\n\n        let currentNode = tree.currentNode; // 获取当前节点指针\n\n        log(currentNode) // body > div\n\n        tree.nextNode() // 移动指针\n\n        log(tree.firstChild()) // 1\n\n        tree.parentNode() // 切换到父节点\n\n        log(tree.lastChild()) // 6\n\n        log(tree.previousSibling()) // 5\n        log(tree.previousNode()) // 4\n    \n\n\n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n\n    \n    \n    \n    Document\n\n\n\n\n    \n        class MyCustomElement extends HTMLElement {\n            constructor() {\n                super()\n                console.log('init', this.childNodes)\n\n                var shadow = this.attachShadow({ mode: 'open' })\n                // 创建一个 spans\n                var wrapper = document.createElement('span');\n                wrapper.setAttribute('class', 'wrapper');\n                var icon = document.createElement('span');\n                icon.setAttribute('class', 'icon');\n                icon.setAttribute('tabindex', 0);\n                var info = document.createElement('span');\n                info.setAttribute('class', 'info');\n                info.textContent = '消费对经济具有持久拉动力，事关保障和改善民生。要贯彻党中央、国务院部署，协同发力、远近兼顾，努力稳定当前消费，综合施策释放消费潜力。'\n\n                shadow.appendChild(wrapper);\n                wrapper.appendChild(icon);\n                wrapper.appendChild(info);\n            }\n\n            connectedCallback() {\n                console.log('Custom square element added to page.');\n            }\n        }\n\n        window.customElements.define('zz-p', MyCustomElement)\n    \n\n\n    \n        sd\n        sdjhfkldsjfklsd\n    \n\n    getSelection\n\n    \n        body {\n            padding: 100px;\n        }\n\n        .box {\n            width: 400px;\n            height: 200px;\n            border: 1px solid #ccc;\n        }\n    \n\n    \n        function btngetSelection() {\n            let selection = shadowRoot.getSelection().getRangeAt(0)\n            console.log(selection.toString())\n        }\n    \n\n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "function forEach(arr, eachFn, doneFn) {\n    var i = -1;\n    // Resolve array length to a valid (ToUint32) number.\n    var len = arr.length >>> 0;\n\n    // This IIFE is called once now, and then again, by name, for each loop\n    // iteration.\n    (function next(result) {\n        // This flag will be set to true if `this.async` is called inside the\n        // eachFn` callback.\n        var async;\n        // Was false returned from the `eachFn` callback or passed to the\n        // `this.async` done function?\n        var abort = result === false;\n\n        // Increment counter variable and skip any indices that don't exist. This\n        // allows sparse arrays to be iterated.\n        do { ++i; } while (!(i in arr) && i !== len);\n\n        // Exit if result passed to `this.async` done function or returned from\n        // the `eachFn` callback was false, or when done iterating.\n        if (abort || i === len) {\n            // If a `doneFn` callback was specified, invoke that now. Pass in a\n            // boolean value representing \"not aborted\" state along with the array.\n            if (doneFn) {\n                doneFn(!abort, arr);\n            }\n            return;\n        }\n\n        // Invoke the `eachFn` callback, setting `this` inside the callback to a\n        // custom object that contains one method, and passing in the array item,\n        // index, and the array.\n        result = eachFn.call({\n            // If `this.async` is called inside the `eachFn` callback, set the async\n            // flag and return a function that can be used to continue iterating.\n            async: function () {\n                async = true;\n                return next;\n            }\n        }, arr[i], i, arr);\n\n        // If the async flag wasn't set, continue by calling `next` synchronously,\n        // passing in the result of the `eachFn` callback.\n        if (!async) {\n            next(result);\n        }\n    }());\n};\n\n\nvar a = [1,2,3,4,5,6]\n\n\nforEach(a, function(item, index) {\n\n    var done = this.async();\n    // Continue in one second.\n    // setTimeout(done, 1000);\n\n    setTimeout(() => {\n        console.log('item--index: ', item, index)\n        done()\n    }, 2000)\n})",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n    \n    \n    \n    Document\n\n\n    \n        let a = {\n            name: 'jack',\n            getName: function() {\n                console.log(this.name)\n            }\n        }\n\n        let b = new Proxy(a, {\n            get: function(target, key) {\n                console.log('get method :', target, key)\n                return target[key]\n            },\n            set: function(target, prop, value, receiver) {\n                console.log('set method: success');\n                target[prop] = value\n                return true\n            }\n        })\n\n        console.log(b.name)\n\n\n        function sum(a, b) {\n            return a + b\n        }   \n\n        let c = new Proxy(sum, {\n            apply: function(target, context, argsList) {\n                console.log('apply: ', argsList) \n                return target.apply(this, argsList) + 10\n            }\n        })\n\n        console.log(c(1, 4))\n\n    \n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n    \n    \n    \n    Document\n\n\n    \n        const _Vue = Vue\n\n        return function render(_ctx, _cache) {\n            with (_ctx) {\n                const {\n                toDisplayString: _toDisplayString,\n                openBlock: _openBlock,\n                createElementBlock: _createElementBlock,\n                createCommentVNode: _createCommentVNode,\n                createTextVNode: _createTextVNode,\n                Fragment: _Fragment,\n                renderList: _renderList,\n                createElementVNode: _createElementVNode,\n                normalizeClass: _normalizeClass,\n                } = _Vue;\n\n                return (\n                _openBlock(),\n                _createElementBlock(\n                    \"div\",\n                    {\n                        id: \"foo\",\n                        class: _normalizeClass(bar.baz),\n                    },\n                    [\n                    _createTextVNode(_toDisplayString(world.burn()) + \" \", 1 /* TEXT */),\n                    ok\n                        ? (_openBlock(), _createElementBlock(\"div\", { key: 0 }, \"yes\"))\n                        : (_openBlock(),\n                        _createElementBlock(\n                            _Fragment,\n                            { key: 1 },\n                            [_createTextVNode(\"no\")],\n                            2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */\n                        )),\n                    (_openBlock(true),\n                    _createElementBlock(\n                        _Fragment,\n                        null,\n                        _renderList(list, (value, index) => {\n                        return (\n                            _openBlock(),\n                            _createElementBlock(\"div\", null, [\n                                _createElementVNode(\n                                    \"span\",\n                                    null,\n                                    _toDisplayString(value + index),\n                                    1 /* TEXT */\n                                ),\n                            ])\n                        );\n                        }),\n                        256 /* UNKEYED_FRAGMENT */\n                    )),\n                    ],\n                    2 /* CLASS */\n                )\n                );\n            }\n        }\n    \n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n    \n    \n    \n    prepend\n\n\n    \n        demo1\n        demo1\n        demo1\n        demo1\n\n        prepend\n        after\n    \n    \n        function prepend(){\n            var h1 = document.querySelector('h1')\n            var p = document.createElement('strong')\n            p.textContent = 'strong'\n            h1.prepend(p)\n        }\n\n        function after() {\n            var h1 = document.querySelector('h2')\n            var p = document.createElement('strong')\n            p.textContent = 'strong'\n            h1.after(p)\n        }\n        \n    \n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n    \n    \n    \n    Document\n\n\n    \n\n    \n\n        function throttle(fn, interval){\n            let flag = true;\n            return function(...args) {\n                let context = this;\n                if(!flag) return;\n                flag = false;\n                setTimeout(() => {\n                    fn.apply(context, args);\n                    flag = true;\n                }, interval)\n            }\n        }\n\n    \n\n\n",
        "tags": []
    },
    {
        "uri": "",
        "content": "\n\n\n    \n    \n    \n    Document\n\n\n    \n\n\n    class MyEvent {\n        constructor() {\n            this._eventMap = new Map()\n        }\n\n\n        on(event, callback) {\n            if(event && typeof callback == 'function') {\n                this._eventMap.has(event) || this._eventMap.set(event, []);\n                this._eventMap.get(event).push(callback);\n            }\n            return this;\n        }\n\n        off(event, callback) {\n            if(event) {\n                if(typeof callback == 'function') {\n                    const callbacks = this._eventMap.get(event) || [];\n                    for(let i in callbacks) {\n                        if(callbacks[i] === callback) {\n                            callbacks.splice(i, 1);\n                        }\n                    }\n                } else {\n                    this._eventMap.delete(event)\n                }\n\n            }\n            return this\n        }\n\n        once(event, callback) {\n\n        }\n\n        emit(event, ...args) {\n            if(!this._eventMap.has(event)) return false;\n            this._eventMap.get(event).map(callback => callback(...args))\n            return true;\n        }\n    }\n\n\n\n\n\n\n\n",
        "tags": []
    },
    {
        "uri": "/posts/2022/06/config/",
        "title": "jenkinsfile 配置说明",
        "content": "\nagent\n\n运行环境，每个pipeline都需要定义运行环境\n\n在执行引擎中，agent 指令会引起以下操作的执行：\n\n所有在块block中的步骤steps会被Jenkins保存在一个执行队列中。 一旦一个执行器 executor 是可以利用的，这些步骤将会开始执行。\n一个工作空间 workspace 将会被分配， 工作空间中会包含来自远程仓库的文件和一些用于Pipeline的工作文件\n\npipeline {\n    agent {\n        docker { image 'node:7-alpine' }\n    }\n    stages {\n        stage('Test') {\n            steps {\n                sh 'node --version'\n            }\n        }\n    }\n}\n\nenvironment\n\n环境变量，可以提供给下面脚本使用\n\n环境变量可以像下面的示例设置为全局的，也可以是阶段（stage）级别的。 如你所想，阶段（stage）级别的环境变量只能在定义变量的阶段（stage）使用。\n\npipeline {\n    agent any\n\n    environment {\n        DISABLE_AUTH = 'true'\n        DB_ENGINE    = 'sqlite'\n    }\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'printenv'\n            }\n        }\n    }\n}\n\npipeline\n\nPipelines 由多个步骤（step）组成，允许你构建、测试和部署应用。 Jenkins Pipeline 允许您使用一种简单的方式组合多个步骤， 以帮助您实现多种类型的自动化构建过程。\n\n可以把“步骤（step）”看作一个执行单一动作的单一的命令。 当一个步骤运行成功时继续运行下一个步骤。 当任何一个步骤执行失败时，Pipeline 的执行结果也为失败。\n\n当所有的步骤都执行完成并且为成功时，Pipeline 的执行结果为成功。\n\n每个stages中可以包含多个stage\n\npipeline {\n    agent any\n    stages {\n        stage('Build') {\n            steps {\n                sh 'echo \"Hello World\"'\n                sh '''\n                    echo \"Multiline shell steps works too\"\n                    ls -lah\n                '''\n            }\n        }\n    }\n}\n\npipeline 流水线声明\nstages 阶段，内部可以包含多个stage, 其中内部stage可以自定义名称，方便日志时打印出来\n  steps 步骤， 就是具体脚本平台执行的命令，不同的系统平台有不同的命令\npost 完成时动作，可以用作清理数据\n  awalys 总是会执行\n  success 成功后执行\n  failure 失败后执行\n  unstable 未稳定构建后执行\n  changed 上次成功，这次失败，即状态变更后执行\n\n重试和超时\n\npipeline {\n    agent any\n    stages {\n        stage('Deploy') {\n            steps {\n                retry(3) {\n                    sh './flakey-deploy.sh'\n                }\n\n                timeout(time: 3, unit: 'MINUTES') {\n                    sh './health-check.sh'\n                }\n            }\n        }\n    }\n}\n\n邮件\n\npost {\n    failure {\n        mail to: 'team@example.com',\n             subject: \"Failed Pipeline: ${currentBuild.fullDisplayName}\",\n             body: \"Something is wrong with ${env.BUILD_URL}\"\n    }\n}\n\npost 完成时执行\n\npipeline {\n    agent any\n    stages {\n        stage('Test') {\n            steps {\n                sh 'echo \"Fail!\"; exit 1'\n            }\n        }\n    }\n    post {\n        always {\n            echo 'This will always run'\n        }\n        success {\n            echo 'This will run only if successful'\n        }\n        failure {\n            echo 'This will run only if failed'\n        }\n        unstable {\n            echo 'This will run only if the run was marked as unstable'\n        }\n        changed {\n            echo 'This will run only if the state of the Pipeline has changed'\n            echo 'For example, if the Pipeline was previously failing but is now successful'\n        }\n    }\n}\n",
        "tags": null
    },
    {
        "uri": "/posts/2022/06/install/",
        "title": "jenkins docker安装说明",
        "content": "\n安装\n\n以docker部署jenkins为例\n\n拉取镜像\n\ndocker pull jenkinsci/blueocean\n\n运行\n\ndocker run \\\n  -u root \\\n  --name jenkins\n  -p 8080:8080 \\\n  -v /data/jenkins-data:/var/jenkins_home \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  jenkinsci/blueocean\n\n把8080端口映射到宿主8080端口\n/var/jenkins_home 映射到宿主 /data/jenkins-data\n/var/run/docker.sock 把宿主的docker运行脚本映射进去\n命名容器的名称为jenkins\n\n容器启动起来以后，可以看到初始密码\n\n安装nodejs插件\n\n先到插件管理下面搜索nodejs插件并安装\n/configureTools下配置nodejs版本，并且勾选自动安装\n\n>  \"Manage Jenkins\" -> \"Global Tool Configuration\" -> \"Add NodeJS\"\n\nGit ssh\n\n配置git ssh\n\n命令行中生成ssh key\n\n   > ssh-keygen -f ~/.ssh/jenkinsagentkey\n\n回到jenkins中， 找到Manage Credentials ， 添加一个新的全局凭证\n\n在输入框中输入ssh生成的private_key\n\n配置插件清华源\n\nhttps://mirrors.tuna.tsinghua.edu.cn/jenkins/\n\n在jenkins插件管理页面，找到高级tab\n\n输入清华源的升级json\n\nhttps://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json\n",
        "tags": null
    },
    {
        "uri": "/posts/2022/06/issues/",
        "title": "jenkins docker部署问题搜集",
        "content": "\nnode command not found\n\njenkinsci/blueocean使用后发现安装的nodejs版本无法使用，node命令无法找到\n\n因为在docker-apline镜像中存在node依赖问题\n\nhttps://stackoverflow.com/questions/43307107/jenkins-nodejsplugin-node-command-not-found\n\n解决方案是使用官方的镜像https://hub.docker.com/r/jenkins/jenkins",
        "tags": null
    },
    {
        "uri": "/posts/2021/09/jenkins-reset-password/",
        "title": "jenkins忘记密码后重置或找回密码",
        "content": "\nJenkins 忘记密码后重置或找回密码\n\n方法1\n\n找到jenkins家目录中的config.xml把其中\n\nfalse\n\nfalse 改为 true\n\n家目录正常在\n\n/var/lib/jenkins\n~/.jenkins\n\n方法2\n输出的就是密码\ncat /var/lib/jenkins/secrects/initialAdminPassword\n\n方法3\n\ncd /var/lib/jenkins/users/admin_xxxxxx\n替换其中\n\n#jbcrypt:$2a$10$F3FuCma14yxF5zVAxelffez7oZoCZzW5Iau/LS5DIvmzugazYZSSS\n\n为\n\n#jbcrypt:$2a$10$4NW.9hNVyltZlHzrNOOjlOgfGrGUkZEpBfhkaUrb7ODQKBVmKRcmK\n\n新密码为123456\n",
        "tags": [
            "jenkins",
            "linux"
        ]
    },
    {
        "uri": "/posts/2021/09/arrayEach/",
        "title": "ArrayEach",
        "content": "ArrayEach实现循环\n\n用while中的break实现原来Array.prototype.forEach未实现的打断功能\nfunction arrayEach(array, iteratee) {\n  // 从左往右\n  let index = -1\n  const length = array.length\n  // 从右往做, 换个思路\n  /**\n   let length = array == null ? 0 : array.length\n   *  while(length--) {\n   if(iteratee(array[length], index, array) === false) ...\n   }\n  */\n\n  while (++index  {\n  console.log(item)\n  return item  {\n  console.log(item)\n  return item > 1\n}) // 1、2、3、4\n",
        "tags": [
            "JS",
            "lodash"
        ]
    },
    {
        "uri": "/posts/2022/06/async-await/",
        "title": "js -- async await基本知识",
        "content": "\nasync await\n\n错误捕获\n\nasync 函数永远返回一个promise\n\n如果没有指定返回值，则默认返回一个resolve promise, 相当于return Promise.resolve()\n如果返回一个值，相当于return Promise.resolve(\"你的值\")\n如果函数中抛出错误, throw new Error, 则相当于return Promise.reject(\"error\")\n\n案例\n\nasync function thisThrows() {\n    throw new Error(\"Thrown from thisThrows()\");\n}\n\ntry {\n    thisThrows();\n} catch (e) {\n    console.error(e);\n} finally {\n    console.log('We do cleanup here');\n}\n\n这里try-catch就不能捕获到错误，因为thisThrows是一个async, 所以在执行的时候，主任务已经结束了，但是子任务还没执行完毕\n\n所以有两种解决方案\n\n把调用thisThrow函数也改造成一个async函数\n调用thisThrow的同时，使用.catch函数去捕获错误\n",
        "tags": [
            "js",
            "asynchronous"
        ]
    },
    {
        "uri": "/posts/2021/09/baseFindIndex/",
        "title": "BaseFindIndex",
        "content": "\nbaseFindIndex\n查找数组中的索引\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  const { length } = array\n  let index = fromIndex + (fromRight ? 1 : -1)\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index\n    }\n  }\n  return -1\n}\n`",
        "tags": [
            "JS",
            "lodash"
        ]
    },
    {
        "uri": "/posts/2021/11/classname-operation/",
        "title": "Classname Operation",
        "content": "\n操作相关classname工具函数\n\n// 增加目标class\nfunction addClass(target = '', srcCls = '') {\n    const clss = target.split(/\\s+/)\n    return [...clss.filter(cls => !clss.includes(cls)), srcCls]\n}\n\nfunction removeClass(target = '', srcCls = '') {\n    const clss = target.split(/\\s+/)\n    return [...clss.filter(cls => !clss.includes(srcCls))]\n}\n",
        "tags": [
            "css",
            "js"
        ]
    },
    {
        "uri": "/posts/2021/11/classnames/",
        "title": "Classnames库代码解读",
        "content": "\n\nclassnames库是日常工作中用来操作dom中class相关的工具函数，这里我们对它进行解读\n\n使用\n\n> npm install classnames --save\n\nfunction classNames() {\n    let classes = [];\n\n    for (let i = 0; i < arguments.length; i++ ) {\n        if(!arguments[i]) {\n            continue\n        }\n\n        const arg = arguments[i]\n\n        if(typeof arg === 'string' || typeof arg === 'number') {\n            // 直接插入\n            classes.push(arg)\n        } else if (Array.isArray(arg)) {\n            // 子项是数组，递归调用自己\n            arg.length && classes.push(classNames.call(null, arg))\n        } else if(typeof arg === 'object') {\n            // 判断是不是object, 是就进行遍历\n            if(arg.toString() === Object.prototype.toString()) {\n                for(let key in arg) {\n                    if(arg[key]) {\n                        classes.push(arg[key])\n                    }\n                }\n            } else {\n                // 不是object, 直接转成字符串\n                classes.push(arg.toString())\n            }\n        }\n\n    }\n\n    return classes.join(' ')\n}\n`",
        "tags": [
            "js"
        ]
    },
    {
        "uri": "/posts/2021/05/connection-between-tab/",
        "title": "原生跨页面通信方案",
        "content": "\n原生跨页面通信api\n\n各API实现跨页面的优缺点：\n\nBroadcast Channel：实时通信，随时关闭频道，功能全面；浏览器支持效果不好（IE-都不支持，chrome-54）\nstorageEvent：浏览器支持效果好、API直观。部分浏览器隐身模式下，无法设置localStorage（如safari）。可能因LocalStorage清理不及时而引起问题\nshareworker：异步处理，不占用主线程，不用 ie 浏览器的话，还是非常推荐的（IE-都不支持）\nserviceworker：浏览器支持度不高，开启service worker可能会导致浏览器的缓存数据大大增加（IE-都不支持）\nwindow.open + window.opener：实现方式不优雅，无法形成统一的解决方案，且在强制刷新页面后会失去关联导致无法通信；实现简单，浏览器兼容性好\npostMessage：点对点通信，局限性比较大，可扩展性比较差。\n",
        "tags": [
            "跨页面通信"
        ]
    },
    {
        "uri": "/posts/2021/11/cookie/",
        "title": "Axios 中 Cookie 操作及代码详解",
        "content": "1)Cookie名称，Cookie名称必须使用只能用在URL中的字符，一般用字母及数字，不能包含特殊字符，如有特殊字符想要转码。如js操作cookie的时候可以使用escape()对名称转码。\\\n> 2)Cookie值，Cookie值同理Cookie的名称，可以进行转码和加密。\\\n> 3)Expires，过期日期，一个GMT格式的时间，当过了这个日期之后，浏览器就会将这个Cookie删除掉，当不设置这个的时候，Cookie在浏览器关闭后消失。\\\n> 4)Path，一个路径，在这个路径下面的页面才可以访问该Cookie，一般设为“/”，以表示同一个站点的所有页面都可以访问这个Cookie。\\\n> 5)Domain，子域，指定在该子域下才可以访问Cookie，例如要让Cookie在a.test.com下可以访问，但在b.test.com下不能访问，则可将domain设置成a.test.com。\\\n> 6)Secure，安全性，指定Cookie是否只能通过https协议访问，一般的Cookie使用HTTP协议既可访问，如果设置了Secure（没有值），则只有当使用https协议连接时cookie才可以被页面访问. \\\n> 7)HttpOnly，如果在Cookie中设置了\"HttpOnly\"属性，那么通过程序(JS脚本、Applet等)将无法读取到Cookie信息。\n\nfunction doCookie() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + \"=\" + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push(\"expires=\" + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push(\"path=\" + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push(\"domain=\" + domain);\n      }\n\n      if (secure === true) {\n        cookie.push(\"secure\");\n      }\n\n      document.cookie = cookie.join(\"; \");\n    },\n\n    read: function read(name) {\n      var match = document.cookie.match(\n        new RegExp(\"(^|;\\\\s)(\" + name + \")=()\")\n      );\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n\n    remove: function remove(name) {\n      this.write(name, \"\", Date.now() - 86400000);\n    },\n  };\n}\n",
        "tags": []
    },
    {
        "uri": "/posts/2021/10/dom-element-api/",
        "title": "HTML Element API 用法",
        "content": "\nElement.append\n\n方法在 Element的最后一个子节点之后插入一组 Node 对象或 DOMString 对象。\n被插入的 DOMString 对象等价为 Text 节点。\n\n> Element.append((Node or DOMString)... nodes);\n\n示例代码\n\n  test\n\n  test2\n\n  var h1 = document.querySelector(\"h1\");\n  var container = document.querySelector(\"#container\");\n\n  let span2 = document.createElement(\"span\");\n  span2.textContent = \"span2\";\n\n  container.append(span2);\n  console.log(container.children);\n\nElement.before\n\n方法可以在这个节点的父节点中插入一些列的 Node 或者 DOMString 对象\n\n> Element.before((Node or DOMString)... nodes);\n\n  test\n\n  test2\n\n  var h1 = document.querySelector(\"h1\");\n  var container = document.querySelector(\"#container\");\n\n  var span = document.createElement(\"span\");\n  span.textContent = \"demo span\";\n\n  h1.after(span);\n\n  var spanBefore = document.createElement(\"span\");\n  spanBefore.textContent = \"spanBebore\";\n\n  span.before(spanBefore);\n\nElement.after\n\n> Element.after(...nodes | Text)\n\n参数为html node 或者直接是 html 文本, 也可以是多个参数同时插入\n\n示例代码\n\n  test\n\n  test2\n\n  var h1 = document.querySelector(\"h1\");\n  var container = document.querySelector(\"#container\");\n\n  var span = document.createElement(\"span\");\n  span.textContent = \"demo span\";\n\n  h1.after(span);\n\nElement.insertBefore\n\nreferenceParentNode.insertBefore(targetNode, referenceNode);\n\n父节点操作下面子节点的方法，referenceNode之前插入一个拥有指定父节点的子节点\n\n使用场景\n\nfunction swap(el1: HTMLElement, el2: HTMLElement) {\n  // 临时节点,相当于锚点标记\n  let temp: HTMLElement = document.createElement(\"div\");\n  // 获取父节点\n  let parent = el1.parentNode;\n  // temp插入到el1前面\n  parent.insertBefore(temp, el1);\n  // el1插入到el2前面\n  parent.insertBefore(el1, el2);\n  // el2插入到temp前面\n  parent.insertBefore(el2, temp);\n  // 删除锚点\n  parent.removeChild(temp);\n}\n\nElement.closest\n\n元素接口的 closest()方法用于遍历 HTML 文档树中的元素及其父元素，直到找到与提供的选择器字符串匹配的第一个节点。只搜索父级节点。\n\ntargetElement.closest(selectors);\n\n参数 此方法接受如上所述和以下描述的单个参数：\n\nselectors 它是一个字符串，它指定将用于查找节点的 HTML 选择器。\n\n返回值 如果找到匹配的祖先，则此方法返回最接近的元素；否则，如果找不到此类元素，则返回 null。\n\nElement.animate\n\n元素的动画效果\n\n示例代码\n\n  test paragraph\n\n  var animate = document.getElementsByTagName(\"h5\")[0].animate(\n    [\n      // keyframes\n      { transform: \"translateY(0px)\" },\n      { transform: \"translateY(-300px)\" },\n    ],\n    {\n      // timing options\n      duration: 1000,\n      iterations: Infinity,\n    }\n  );\n\nh5标签会一直在动画状态\n\nanimate.pause(); // 暂停\nanimate.cancel(); // 取消暂停状态\nanimate.effect;\n\nElement.getAttribute\n\n获取元素相关属性\n\nElement.getAttributeNames\n\n获取元素所有属性Array\n\nElement.insertAdjacentElement\n\n> element.insertAdjacentElement(position, element)\n\n返回插入的元素， 插入失败则返回 null\n\nposition 可选值\n\nbeforebegin: 在该元素本身的前面.\nafterbegin:只在该元素当中, 在该元素第一个子孩子前面.\nbeforeend:只在该元素当中, 在该元素最后一个子孩子后面.\nafterend: 在该元素本身的后面.\n\nelement => dom 元素\n\n插入结果位置\n\nfoo\n\nElement.getAttributeNode\n\n返回指定元素的指定属性节点\n\n> var attrNode = element.getAttributeNode(attrName);\n\nattrNode  获得的属性返回值，是Attr 节点， nodeType 为 2\nattrName 是一个包含属性名称的 字符串\n\n    var el = document.querySelector('#app')\n    var idAttr = el.getAttributeNode(\"id\")\n\nElement.getBoundingClientRect()\n\n返回元素的大小及其相对于浏览器视窗的位置。\n\n返回 top,lef,right,bottom,width,height 6个值\n\n注意： 该API返回的 DOMRect 对象在现代浏览器中可以被修改。\n",
        "tags": [
            "Element",
            "js"
        ]
    },
    {
        "uri": "/posts/2021/11/event-bus/",
        "title": "事件总线EventBus",
        "content": "\n\n日常我们在vue开发的时候使用公共事件总线进行跨组建数据传递，这里我们自己封装一个事件总线，了解其背后的原理\nclass MyEvent {\n    constructor() {\n        this._eventMap = new Map()\n    }\n\n    on(event, callback) {\n        if(event && typeof callback == 'function') {\n            this.eventMap.has(event) || this.eventMap.set(event, []);\n            this._eventMap.get(event).push(callback);\n        }\n        return this;\n    }\n\n    off(event, callback) {\n        if(event) {\n            if(typeof callback == 'function') {\n                const callbacks = this._eventMap.get(event) || [];\n                for(let i in callbacks) {\n                    if(callbacks[i] === callback) {\n                        callbacks.splice(i, 1);\n                    }\n                }\n            } else {\n                this._eventMap.delete(event)\n            }\n\n        }\n        return this\n    }\n\n    once(event, callback) {\n\n    }\n\n    emit(event, ...args) {\n        if(!this._eventMap.has(event)) return false;\n        this._eventMap.get(event).map(callback => callback(...args))\n        return true;\n    }\n}\n",
        "tags": [
            "js",
            "utils"
        ]
    },
    {
        "uri": "/posts/2022/05/event-loop/",
        "title": "js Event Loop 事件循环执行机制",
        "content": "\nJavascript engine list\n\nv8引擎高效原因\n\nV8) — open source, developed by Google, written in C++\nRhino) — managed by the Mozilla Foundation, open source, developed entirely in Java\nSpiderMonkey) — the first JavaScript engine, which back in the days powered Netscape Navigator, and today powers Firefox\nJavaScriptCore — open source, marketed as Nitro and developed by Apple for Safari\nKJS) — KDE’s engine originally developed by Harri Porten for the KDE project’s Konqueror web browser\nChakra (JScript9)) — Internet Explorer\nChakra (JavaScript)) — Microsoft Edge\nNashorn), open source as part of OpenJDK, written by Oracle Java Languages and Tool Group\nJerryScript — is a lightweight engine for the Internet of Things.\n\nV8把JavaScript代码编译成机器码，而不是使用解释器.\n\n它通过像许多现代 JavaScript 引擎（例如 SpiderMonkey 或 Rhino (Mozilla)）一样实现 JIT（即时）编译器，在执行时将 JavaScript 代码编译成机器代码\n\nv8不生成任何字节码或者其他中间代码\n\n异步（asynchronous     [eɪˈsɪŋkrənəs]）执行运行机制\n\n所有同步任务都在主线程上执行，形成一个执行栈\n主线程之外还存在一个任务队列，异步任务有了结果，就会在任务队列中放置一个事件\n同步任务执行完毕后，系统就会读取任务队列中的任务\n\n宏任务\n\nI/O\nsetTimeout\nsetInterval\nsetImmediate(node.js)\nrequestAnimationFrame\n\n微任务\n\nPromise.then\n\nprocess.nextTick(node.js)\nMutationObserver\n\nNode.js中的Event Loop\n\nNode.js采用v8作为js的解析引擎，I/O处理方面采用libuv\n\n运行机制：\n\nv8解析javascript脚本文件\n调用Node API\nlibuv负责Node API的执行。把任务分配给不同的线程，形成EventLoop, 把结果以异步的方式返回给v8引擎\nv8把结果返回给用户\n\nnodejs的event loop分为6个阶段\n\ntimers：执行setTimeout() 和 setInterval()中到期的callback。\nI/O callbacks：上一轮循环中有少数的 I/O callback 会被延迟到这一轮的这一阶段执行\nidle, prepare：队列的移动，仅内部使用\npoll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段\ncheck：执行setImmediate的callback\nclose callbacks：执行close事件的callback，例如socket.on(\"close\",func)\n\n注意点\n\n每个阶段完成后，都会执行清空微任务队列\ntimers阶段执行创建的setImmediate事件，会在本轮循环的check阶段执行完毕，而timers阶段创建的setTimeout事件，会进入下轮循环执行\nNode中同个MicroTask队列下， process.nextTick比Promise更加优先\n\n事件循环执行代码解析\n\nlet count = 0;\n\n(function(count) {\n    console.log('count1:', count);\n    a(++count)\n    console.log('count1-1:',count);\n})(count)\n\nasync function a(count) {\n    console.log('count2:', count);\n    await b(count++)\n    console.log('count3:', count);\n}\n\nasync function b(count) {\n    console.log('count4:', count);\n}\n\nnew Promise((resolve) => {\n    console.log('count6:', count);\n    resolve(count++)\n}).then(count => {\n    console.log('count7:', count);\n})\n\nsetTimeout(() => {\n    console.log('count8:', count);\n    Promise.resolve().then(() => {\n        console.log('count8-1', count);\n    })\n})\n\nconsole.log('count9:', count);\n\n开头是一个自执行函数， 执行到count1\na函数调用 count2\na里面调用b，b是一个异步函数，这里b会执行 count4\n回到a函数， count3推送微任务队列\n回到一开始的自执行函数，往下执行 count1-1\n自执行函数同步任务执行完毕，主任务同步任务执行\n执行到new Promise\ncount6打印， then方法推到微任务队列\n往下执行，一个setTimeout推入宏任务队列\ncount9打印\n微任务队列执行，先入先出原则\n执行count3\n执行count7\n宏任务队列执行\n执行count8,宏任务重产生微任务\n清空微任务，打印count8-1\n\n引用\n\nhttps://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e",
        "tags": null
    },
    {
        "uri": "/posts/2021/11/isElement/",
        "title": "判断是不是DOM元素",
        "content": "\nfunction isElement(obj: any) {\n    try {\n        // Using W3 DOM2 (works for FF, Opera and Chrome)\n        return obj instanceof HTMLElement;\n    } catch (e) {\n        // Browsers not supporting W3 DOM2 don't have HTMLElement and\n        // an exception is thrown and we end up here. Testing some\n        // properties that all elements have (works on IE7)\n        return (\n            typeof obj === 'object' &&\n            obj.nodeType === 1 &&\n            typeof obj.style === 'object' &&\n            typeof obj.ownerDocument === 'object'\n        );\n    }\n}\n`",
        "tags": [
            "js",
            "dom"
        ]
    },
    {
        "uri": "/posts/2021/09/isPromise/",
        "title": "常用判断函数",
        "content": "\n是否是promise\nexport function isPromise(object: any): object is Promise {\n  return Promise.resolve(object) === object;\n}\n`",
        "tags": [
            "js"
        ]
    },
    {
        "uri": "/posts/2022/06/JSON.stringify/",
        "title": "JSON.stringify方法",
        "content": "\nJSON.parse\n\n> > JSON.parse(text[, reviver])\n>\n\nreviver\n\n转换器，如果传入该参数 (函数)，可以用来修改解析生成的原始值，调用时机在 parse 函数返回之前。\n\n解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 reviver 函数\n\n从最内层开始，按照层级顺序，依次向外遍历\n\nJSON.stringify\n\n> > JSON.stringify(value[, replacer [, space]])\n>\n\nvalue转换规则\n\n值如果有 toJSON() 方法，按toJSON方法输出。\n非数组对象的属性 转换后顺序不固定。\n布尔值、数字、字符串会转换成原始值。\n常规对象中undefined、函数以及 symbol ，会被忽略\n数组中 undefined、函数以及 symbol 会 被转换成 null。\n函数、undefined 被单独转换时，会返回 undefined。\n循环引用的对象会报错。\nsymbol 属性键的属性都会被移除。\nDate 会转为字符串。\nNaN 、Infinity 、 null 都会被当做 null。\nMap/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。\n\nreplacer\n\n2个参数，包括key和value\n\nfunction replacer(key, value) {\n  if (typeof value === \"string\") {\n    return undefined;\n  }\n  return value;\n}\n\nvar foo = {foundation: \"Mozilla\", model: \"box\", week: 45, transport: \"car\", month: 7};\nvar jsonString = JSON.stringify(foo, replacer); // {\"week\":45,\"month\":7}\n\nspace\n\n参数用来控制结果字符串里面的间距, 用来格式化json\n\nJSON.stringify({ a: 2 }, null, \" \");   // '{\\n \"a\": 2\\n}'\n",
        "tags": [
            "JSON.stringify"
        ]
    },
    {
        "uri": "/posts/2021/11/lodash-toNumber/",
        "title": "Lodash ToNumber",
        "content": "\ntoNumber\n\nlodash中转数字函数\n\nfunction isObject(value) {\n  const type = typeof value\n  return value != null && (type === 'object' || type === 'function')\n}\n\nfunction isSymbol(value) {\n  const type = typeof value\n  return type == 'symbol' || (type === 'object' && value != null && getTag(value) == '[object Symbol]')\n}\n\n/* Used as references for various Number constants. /\nconst NAN = 0 / 0\n\n/* Used to match leading and trailing whitespace. /\nconst reTrim = /^\\s+|\\s+$/g\n\n/* Used to detect bad signed hexadecimal string values. /\n// 是否是十六进制数据\nconst reIsBadHex = /^[-+]0x[0-9a-f]+$/i\n\n/* Used to detect binary string values. /\nconst reIsBinary = /^0b[01]+$/i\n\n/* Used to detect octal string values. /\nconst reIsOctal = /^0o[0-7]+$/i\n\n/* Built-in method references without a dependency on root. /\nconst freeParseInt = parseInt\n\nfunction toNumber(value) {\n  // 类型是Number\n  if (typeof value === 'number') {\n    return value\n  }\n  // 类型是symbol\n  if (isSymbol(value)) {\n    return NAN\n  }\n  // 如果是对象，取出对象的值或者转成字符串\n  if (isObject(value)) {\n    const other = typeof value.valueOf === 'function' ? value.valueOf() : value\n    value = isObject(other) ? ${other} : other\n  }\n  // 不是字符串的情况\n  if (typeof value !== 'string') {\n    return value === 0 ? value : +value\n  }\n  // 去除两边空格\n  value = value.replace(reTrim, '')\n  // 是否是二进制数据\n  const isBinary = reIsBinary.test(value)\n  // 是否是八进制数据\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value)\n}\n\nparseInt函数解析\n\n第一个参数，string\n第二个参数， 2～36 表示解析数据的基数\n\n> parseInt函数将其第一个参数转换为一个字符串，对该字符串进行解析，然后返回一个整数或 NaN。\n> 如果不是NaN，返回值将是以第一个参数作为指定基数 radix 的转换后的十进制整数。(例如，radix为10，就是可以转换十进制数，为8可以转换八进制数\"07\"，16可以转换十六进制数\"0xff\"，以此类推)。\n> 对于 radix 为10以上的，英文字母表示大于9的数字。例如，对于十六进制数（基数16），则使用 A 到 F 。\n> 如果 parseInt 遇到的字符不是指定 radix 参数中的数字，它将忽略该字符以及所有后续字符，并返回到该点为止已解析的整数值。 parseInt 将数字截断为整数值。 允许前导和尾随空格。\n",
        "tags": [
            "js"
        ]
    },
    {
        "uri": "/posts/2021/10/mini-page-watch/",
        "title": "小程序中监听data中数据变化方式",
        "content": "\n小程序中监听data中数据变量的变化\n\n// 监听页面数据变化\nexport const PageWatch = (_page) => {\n  if (!_page) {\n    console.error('未检测到Page对象,请将当前page传入该函数');\n    return false;\n  }\n  if (!_page.watch) { //判断是否有需要监听的字段\n    console.error('未检测到Page.watch字段(如果不需要监听，请移除initWatch的调用片段)');\n    return false;\n  }\n  let dataKey = Object.keys(page.data);\n  Object.keys(page.watch).map((key) => { //遍历需要监听的字段\n    page.data['' + key] = page.data[key]; //存储监听的数据\n    if (dataKey.includes(key)) { //如果该字段存在于Page.data中，说明合法\n      Object.defineProperties(_page.data, {\n        [_key]: { //被监听的字段\n          enumerable: true,\n          configurable: true,\n          set: function (value) {\n            let oldVal = this['_' + key];\n            if (value !== oldVal) { //如果新设置的值与原值不等，则触发监听函数\n              setTimeout(function () { //为了同步,否则如果回调函数中有获取该字段值数据时将不同步,获取到的是旧值\n                page.watch[key].call(_page, oldVal, value); //设置监听函数的上下文对象为当前的Page对象并执行\n              }.bind(this), 0);\n            }\n            this['_' + key] = value;\n          },\n          get: function () {\n            return this['_' + key];\n          }\n        }\n      });\n    } else {\n      console.error('监听的属性[' + _key + ']在Page.data中未找到，请检查~');\n    }\n  });\n};\n使用方法\nPage({\n    data: {\n        foo: 'abc'\n    },\n    watch: {\n        'foo': function(newValue, oldValue) {\n            ...\n        }\n    }\n})\n`",
        "tags": [
            "js",
            "小程序"
        ]
    },
    {
        "uri": "/posts/2021/10/no-refresh-page/",
        "title": "防抖与节流",
        "content": "\nno-refresh-page\n\n>  history.pushState(\n>    {},\n>    null,\n>    this.$route.path + '#' + encodeURIComponent(params)\n>  )",
        "tags": [
            "js"
        ]
    },
    {
        "uri": "/posts/2021/11/number-plus-minus/",
        "title": "数字加减问题解决精度问题",
        "content": "\n\nfunction plus(num1, num2) {\n    const num1Digits = (num1.toString().split('.')[1] || '').length;\n    const num2Digits = (num2.toString().split('.')[1] || '').length;\n    const baseNumber = Math.pow(10, Math.max(num1Digits, num2Digits));\n    return (num1 * baseNumber + num2 * baseNumber) / baseNumber;\n}\n\nfunction minus(num1, num2) {\n    return plus(num1, -1 * num2);\n}\n",
        "tags": [
            "js"
        ]
    },
    {
        "uri": "",
        "content": "\n\ntitle: \"performance\"\ndate: 2022-06-27T17:11:11+08:00\ndraft: true\ntags: [\"bind\"]\n\nfunction test(f) {\n    console.time()\n    let i = 0\n    while (i++ performance.now())\n`",
        "tags": []
    },
    {
        "uri": "/posts/2021/11/lerna/",
        "title": "Lerna 包管理器命令行",
        "content": "\n$ npm install lerna -g\n$ mkdir lerna-demo\n$ cd lerna-demo && lerna init --independent # 用的默认的固定模式，vue babel等都是这个\n\n$ cd packages\n$ mkdir moduleA && mkdir moduleB\n...\n#分别进入三个目录初始化成包\n$ cd moduleA\n$ npm init -y && touch index.js\n$ cd moduleB\n$ npm init -y && touch index.js\n\n$ lerna add lodash-es # 所有的子包添加相同的依赖\n\nScript\n\n1. lerna create  [loc]\n\n> 创建一个包，name包名，loc 位置可选\n\n2. lerna add [@version] [--dev] [--exact]\n\n> 增加本地或者远程package做为当前项目packages里面的依赖\n\n--dev devDependencies 替代 dependencies\n--exact 安装准确版本，就是安装的包版本前面不带^, Eg: \"^2.20.0\" ➜ \"2.20.0\"\n\n3. lerna list\n> 列出所有的包\n\n➜  lerna-demo git:(master) ✗ lerna list\nlerna notice cli v4.0.0\nlerna info versioning independent\nmodulea\nmoduleb\nlerna success found 2 packages\n\n4. lerna import\n> 导入本地已经存在的包\n\n5. lerna run\n> 运行所有包里面的有这个script的命令\n\n6. lerna exec\n\n> 运行任意命令在每个包\n\n$ lerna exec --  [..args] # runs the command in all packages\n$ lerna exec -- rm -rf ./node_modules\n$ lerna exec -- protractor conf.js\nlerna exec --scope my-component -- ls -la\n\n7. lerna link\n> 项目包建立软链，类似npm link\n\n8. lerna clean\n> 删除所有包的node_modules目录\n\n9. lerna publish\n\n> 会打tag，上传git,上传npm。",
        "tags": [
            "js",
            "nodejs"
        ]
    },
    {
        "uri": "/posts/2021/09/linux-command/",
        "title": "Linux 常用命令",
        "content": "\n查看端口占用\n\n> lsof -i tcp:80\n\n所有端口\n\n> netstat -ntlp\n\n查看端口进程\n\n> netstat -lnp|grep 端口号\n\n> netstat -anp|grep 端口号\n\nLinux内核版本命令\n> cat /proc/version\n\n> uname -a\n\n查看Linux系统版本的命令\n> lsb_release -a\n\n> cat /etc/redhat-release\n\n> cat /etc/issue\n\nldd\n\nldd 用来打印或者查看程序运行所需的共享库,常用来解决程序因缺少某个库文件而不能运行的一些问题。ldd不是一个可执行程序，而只是一个shell脚本。\n\nbash-5.1# ldd ./node\n\t/lib64/ld-linux-x86-64.so.2 (0x7f42c6fe6000)\n\tlibdl.so.2 => /lib64/ld-linux-x86-64.so.2 (0x7f42c6fe6000)\nError loading shared library libstdc++.so.6: No such file or directory (needed by ./node)\n\tlibm.so.6 => /lib64/ld-linux-x86-64.so.2 (0x7f42c6fe6000)\nError loading shared library libgcc_s.so.1: No such file or directory (needed by ./node)\n\tlibpthread.so.0 => /lib64/ld-linux-x86-64.so.2 (0x7f42c6fe6000)\n\tlibc.so.6 => /lib64/ld-linux-x86-64.so.2 (0x7f42c6fe6000)\nError loading shared library ld-linux-x86-64.so.2: No such file or directory (needed by ./node)\n",
        "tags": [
            "linux"
        ]
    },
    {
        "uri": "/posts/2021/09/linux-install-homebrew/",
        "title": "Windows WSL 安装 Homebrew",
        "content": "\nwsl 安装Homebrew 进行包管理\n\n1. 前提\n\n> 操作系统 Windows10\n\n安装wsl，可从微软商店安装，网上教程很多（前提打开主板虚拟化），以下教程不包括安装wsl步骤\n\n2. 步骤\n进入到/home目录，也就是家目录\n\n下载清华homebrew git仓库，当然你也可以从github下载，但是太大国内下载速度感人\n从本镜像下载安装脚本并安装 Homebrew / Linuxbrew\ngit clone --depth=1 https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/install.git brew-install\n/bin/bash brew-install/install.sh\nrm -rf brew-install\n把命令路径加入到配置文件中\ntest -d ~/.linuxbrew && eval \"$(~/.linuxbrew/bin/brew shellenv)\"\ntest -d /home/linuxbrew/.linuxbrew && eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\ntest -r ~/.bashprofile && echo \"eval \\\"\\$($(brew --prefix)/bin/brew shellenv)\\\"\" >> ~/.bashprofile\ntest -r ~/.profile && echo \"eval \\\"\\$($(brew --prefix)/bin/brew shellenv)\\\"\" >> ~/.profile\ntest -r ~/.zprofile && echo \"eval \\\"\\$($(brew --prefix)/bin/brew shellenv)\\\"\" >> ~/.zprofile\n\n最后附上清华homebrew源地址\nhttps://mirror.tuna.tsinghua.edu.cn/help/homebrew/",
        "tags": [
            "安装教程",
            "WSL",
            "linux"
        ]
    },
    {
        "uri": "/posts/2022/05/creat-react-app-issue/",
        "title": "create-react-app 使用中相关问题整理",
        "content": "\n1.test添加代码覆盖率\n\n命令修改为\n\nreact-scripts test --coverage --watchAll=false\n\npackage.json\n\n\"jest\": {\n  \"collectCoverageFrom\": [\n    \"src/*/.{js,jsx,ts,tsx}\",\n    \"!/node_modules/\"\n  ],\n  \"coverageThreshold\": {\n    \"global\": {\n      \"lines\": 90,\n      \"statements\": 90\n    }\n  }\n}\n",
        "tags": null
    },
    {
        "uri": "/posts/2022/05/forwardRef/",
        "title": "React ForwardRef用法",
        "content": "\nForwardRef\n\nforwardRef\n\nref\n\nRef挂载到DOM元素上时，就是对DOM元素本身的使用\nRef挂载到Class组件的时候，就是class组件实例的引用，可以调用实例本身的属性和方法\nRef不能作用到函数式组件上，函数式组件没有实例，所以就要使用这个forwardRef包裹一下函数式组件\n\nForwardRef\n\nForwardRef在react中用作ref转发\n\nfowardRef传入一个函数，返回值是一个react组件\n\n> React.forwardRef()\n\n其中第二个参数就是ref, 可以透传到任意dom元素上\n\nconst Demo = React.forwardRef((props, ref) => {\n\n\treturn (\n\n        //...\n\n  );\n})\n\nuseImperativeHandle\n\n函数式组件中配合useImperativeHandle一起使用\n\n当你函数式组件需要暴露给外部组件一个对象时，需要使用useImperativeHandle勾子函数进行暴露\n\nconst Child = forwardRef((props, ref) => {\n  const [color, setColor] = useState(\"red\");\n  // To customize the value that the parent will get in their ref.current:\n  // pass the ref object to useImperativeHandle as the first argument.\n  // Then, whatever will be returned from the callback in the second argument,\n  // will be the value of ref.current.\n  // Here I return an object with the toggleColor method on it, for the parent to use:\n  useImperativeHandle(ref, () => ({\n    toggleColor: () => setColor(prevColor => prevColor === \"red\" ? \"blue\" : \"red\")\n  }));\n  return yo;\n});\n\nclass Parent extends Component {\n  childRef = createRef();\n  handleButtonClicked = () => {\n    // Ref passed to a function component wrapped in forwardRef.\n    // Note that nothing has changed for this Parent component\n    // compared with the class component in example 2!\n    this.childRef.current.toggleColor();\n  }\n  render() {\n    return (\n\n        toggle color!\n\n    );\n  }\n}\n",
        "tags": [
            "react"
        ]
    },
    {
        "uri": "/posts/2022/05/react-hooks-functional/",
        "title": "React 函数式组件使用手册",
        "content": "\nReact Hooks Functional对应class Component生命周期写法\n\ncomponentDidMount\n\nuseEffect(() => {\n  // Your code here\n}, []);\n\ncomponentDidUpdate\n\nuseEffect(() => {\n  // Your code here\n}, [yourDependency]);\n\ncomponentWillUnmount\n\nuseEffect(() => {\n  // componentWillUnmount\n  return () => {\n     // Your code here\n  }\n}, [yourDependency]);\n\nRef.current作为useEffect的依赖\n\n> Mutable values like 'ref.current' aren't valid dependencies because mutating them doesn't re-render the component.\n\n因为引用不会触发渲染，因此不会触发useEffect渲染\n\nconst Foo = () => {\n  const [, render] = useReducer(p => !p, false);\n  const ref = useRef(0);\n\n  const onClickRender = () => {\n    ref.current += 1;\n    render();\n  };\n\n  const onClickNoRender = () => {\n    ref.current += 1;\n  };\n\n  useEffect(() => {\n    console.log('ref changed');\n  }, [ref.current]);\n\n  return (\n\n      Render\n      No Render\n\n  );\n};\n\n正确获取组件ref实例\n\nconst Component = () => {\n  const [isMounted, toggle] = useReducer((p) => !p, true);\n  const [elementRect, setElementRect] = useState();\n\n  const handleRect = useCallback((node) => {\n    setElementRect(node?.getBoundingClientRect());\n  }, []);\n\n  return (\n\n      {isMounted && Example}\n      Toggle\n      {JSON.stringify(elementRect, null, 2)}\n\n  );\n};\n\n动态创建portal\n\nimport { memo, useEffect, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\n\nconst Portal = ({ id, children }) => {\n\n  const el = useRef(document.getElementById(id) || document.createElement('div'));\n  const [dynamic] = useState(!el.current.parentElement);\n\n  useEffect(() => {\n\n    if (dynamic) {\n      el.current.id = id;\n      document.body.appendChild(el.current);\n    }\n\n    return () => {\n      if (dynamic && el.current.parentElement) {\n        el.current.parentElement.removeChild(el.current);\n      }\n    }\n\n  }, [id]);\n\n  return createPortal(children, el.current);\n};\nexport default memo(Portal);\n",
        "tags": [
            "react"
        ]
    },
    {
        "uri": "/posts/2022/05/react-ref-and-createRef/",
        "title": "React Ref and CreateRef",
        "content": "\nuseRef vs createRef\n\n组件每次渲染都会执行createRef生成一个ref对象\nuseRef在第一次渲染后创建一个ref对象, 重新渲染后如果发现已经创建就不会再执行了\n\nimport React, { useRef, createRef, useState } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nfunction App() {\n  const [renderIndex, setRenderIndex] = useState(1);\n  const refFromUseRef = useRef();\n  const refFromCreateRef = createRef();\n  if (!refFromUseRef.current) {\n    refFromUseRef.current = renderIndex;\n  }\n  if (!refFromCreateRef.current) {\n    refFromCreateRef.current = renderIndex;\n  }\n  return (\n\n      Current render index: {renderIndex}\n\n      First render index remembered within refFromUseRef.current:\n      {refFromUseRef.current}\n\n      First render index unsuccessfully remembered within\n      refFromCreateRef.current:\n      {refFromCreateRef.current}\n\n       setRenderIndex(prev => prev + 1)}>\n        Cause re-render\n\n  );\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(, rootElement);\n\n",
        "tags": [
            "react"
        ]
    },
    {
        "uri": "/posts/2022/05/react-rerender/",
        "title": "React Rerender重绘原理",
        "content": "\nreact rerender原理\n\nreact中组件重绘是一个不可避免的问题，因为react中组件的更新方式就是旧组件销毁，新组件替代旧组件的形式。而且react组件中以树的形式进行构建，必然带来的就是父组件更新，其所有的子组件都会更新\n\n// 父组件\nfunction ListComp() {\n  const [list, setList] = useState([\n    {\n      id: 1,\n      value: \"\",\n    },\n    {\n      id: 2,\n      value: \"\",\n    },\n    {\n      id: 3,\n      value: \"\",\n    },\n  ]);\n\n  return (\n\n      {JSON.stringify(list)}\n\n        {list.map((item, idx) => (\n           {\n              setList(\n                list.map((item) => {\n                  if (item.id === id) {\n                    item.value = value;\n                  }\n                  return item;\n                })\n              );\n            }}\n          >\n        ))}\n\n  );\n}\n\n// 子组件\nfunction Item({ id, value, onChange }) {\n  return (\n\n      {id}\n       onChange(id, e.target.value)}\n      />\n\n  );\n}\n\n在只输入一个输入框的同时，其他子组件都在重新渲染\n\n当组件的状态发生变化时，组件及其子组件都会rerender\n\n如果不想子组件发生不必要的render，使用memo包裹一下组件\n\nconst Item = memo(() => Item)\n\n可以看到父组件更新后，子组件不会再发生rerender了\n\n我重新包裹一下我们的子组件Item\n\nconst ItemWrapper = memo(Item)\n\n子组件还是会发生不必要的rerender\n\n当组件使用memo包裹后还会发生rerender，说明组件又props发生了变化\n\n排查后就是onChange属性发生了变化， 每次父组件rerender后子组件都会重新生产一个onChange事件\n\nonChange={(id: number, value: any) => {\n  setList(\n    list.map((item) => {\n      if (item.id === id) {\n        item.value = value;\n      }\n      return item;\n    })\n  );\n}}\n\n使用useCallback对属性进行缓存，useCallback会生成一个函数缓存\n\n  const onChange = useCallback((id: any, value: any) => {\n    setList((preList) =>\n      preList.map((item) => {\n        if (item.id === id) {\n          item.value = value;\n        }\n        return item;\n      })\n    );\n  }, []);\n\n最终代码\n\nconst Item: React.FC = memo(({ id, value, onChange }: any) => {\n  return (\n\n      {id}\n       onChange(id, e.target.value)}\n      />\n\n  );\n});\n\nconst Parent = () => {\n  const [items, setItems] = useState([\n    { value: \"\", id: 1 },\n    { value: \"\", id: 2 },\n    { value: \"\", id: 3 },\n  ]);\n  const onChange = useCallback((id: any, value: any) => {\n    setItems(\n      items => items.map((item) => {\n        if(item.id === id) {\n          item.value = value\n        }\n        return item;\n      })\n    );\n  }, []);\n\n  return (\n\n      {JSON.stringify(items)}\n      {items.map((item, index) => (\n\n      ))}\n\n  );\n};\n\nhttps://alexsidorenko.com/blog/react-list-rerender/\n",
        "tags": null
    },
    {
        "uri": "/posts/2022/05/react-usage-issue/",
        "title": "React Usage Issue",
        "content": "\nnot assignable to type LegacyRef\\\n\nuseRef定义一个ref时，报不能推断类型\n\nimport React, { useRef, RefObject } from 'react';\n\nfunction Test()\n{\n    const node = useRef(null);\n\n    if (\n        node &&\n        node.current &&\n        node.current.contains()\n    ){ console.log(\"current accessed\")}\n\n    return\n}\n\n因为useRef是使用HTMLElement定义的泛型，所以说不能推断，改成ref所对应的标签泛型就可以了\n\nCannot assign to 'current' because it is a read-only property\n\n当在react中使用useRef定义ref时，报这样的错误, 因为结果走到React.RefObject\n\nuseRef有这3种定义\n\nfunction useRef(initialValue: T): MutableRefObject;\n\nfunction useRef(initialValue: T|null): RefObject;\n\nfunction useRef(): MutableRefObject;\n\nuseRef初始值设为null\nuseRef定义了一个初始的类型\n\nconst elem = useRef(null);\n\ntype Test = typeof elem; // Test = React.RefObject\n`",
        "tags": null
    },
    {
        "uri": "/posts/2022/05/react-usage/",
        "title": "react 使用方法",
        "content": "\nHooks\n\n1. forceUpdate\n\nconst [state, updateState] = React.useState();\nconst forceUpdate = React.useCallback(() => updateState({}), []);\n\nClass Componet\n\n1.forceUpdate\n\n this.forceUpdate();\n",
        "tags": null
    },
    {
        "uri": "/posts/2022/07/tcp-ip/",
        "title": "TCP/IP学习笔记",
        "content": "\nTCP/IP\n\nTCP（传输控制协议）和IP（网际协议 是最先定义的两个核心协议，所以才统称为TCP/IP协议族\n\n应用层\n\nHTTP 万维网\nFTP 文件传输服务\nSMTP 电子邮件服务\nSSH 远程登陆服务\nDNS 名称 IP地址寻找,域名系统\n\n传输层\n\nTCP：面向连接的Transmisson Control Protocol传输控制协议\nUDP : 无连接的包传输User DataProtocol用户数据报协议\n\n网络层\n\nIP： 地址和路由\n\n链路层\n\n操作系统\n硬件设备驱动\nNIC（Network interface Card 网络适配器：网卡 ）\n光纤等物理可见部分\n\n三次握手和四次挥手\n\n三次握手\n\n客户端A发送报文SYN=1 seq=x，请求与服务端B连接\n服务端B收到后确认，发送报文SYN=1 ACK=1 seq=y ack=x+1\n客户端A收到服务端B的确认后，给B发送确认报文ACK=1 seq=x+1 ack=y+1\n\n四次挥手\n\nA向B发送主动关闭的报文FIN=1 seq=u\nB收到后向A发送确认报文 ACK=1 seq=v ack=u+1\nB已经确认没有数据要向A发送了，通知A即将关闭的报文FIN=1 ACK=1 seq=w ack=u+1\nA在收到B的连接释放报文段后，最后确认ACK=1 seq=u+1 ack=w+1\n\n名词解释\n\nACK ：是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。\n\nSYN： 同步序列号，TCP建立连接时将这个位置1。\n\nFIN： 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。\n\nSEQ：初始序列号\n\n保活计时器 keepalive timer\n\n服务器向客户端发送，服务器每收到一次客户端数据就重置保活计时器。若两小时没有收到客户数据，服务器就发送一个探测报文，每隔75s发送一次，连续10个仍无响应就认为客户端出现故障，关闭这个TCP连接。",
        "tags": [
            "tcp",
            "ip"
        ]
    },
    {
        "uri": "/posts/2022/06/caddy/",
        "title": "Caddy ",
        "content": "\ncaddy\n\n是一个类似于nginx的web服务器，只不过是用Go写的，在配置上，要比nginx配置更简单，配置文件使用caddyfile， 默认开箱就是支持https的\n\n下载\n\nDownload Caddy (caddyserver.com)\n\n安装\n\nInstall — Caddy Documentation (caddyserver.com)\n\nwindows\n\n下载指定打包后的exe文件，放到system32目录下，就能在终端中使用了\n\n> // 格式化\n>\n> caddy fmt\n>\n>  // 前台运行\n>\n> caddy run\n>\n>  // 后台运行\n>\n> caddy start\n\ncaddyfile语法\n\n一个可选的全局配置块需要在文件的最上方\n否则，文件的最上方总是服务的地址address\n所有的指令和匹配器必须放在网站块中，这里没有全局scope或者通过网站块继承\n如果只有一个网站块， {}就是可选的\n\nusage\n\n配置目录下新建文件名为Caddyfile的文件，caddy区别于nginx最大的特点就是配置文件简单，对于新手来说非常友好\n\nlocalhost\nrespond \"hello caddy1\"\n\n配置文件目录下执行caddy run,就可以看到在控制台里有日志打印记录\n\n其中看到localhost:2019什么的，其实是当前caddy服务的端口\n\n浏览器中输入localhost:2019/config，能看到当前caddyfile最终转换成的json配置文件\n\n配置文件中第一行是localhost\n\n浏览器中输入localhost, 最终就是返回我们第二行输入的respond出来的字符串\n\n这里我们就能看到，caddy作为一个正向代理，反向代理，最合适不过了\n\n接口代理\n\n新建一个模拟接口\n\nconst http = require(\"http\")\n\nconst app = http.createServer((req, res) => {\n    res.writeHead(200, { 'Content-Type': 'application/json' });\n    res.end(JSON.stringify({\n      data: 'Hello World!'\n    }));\n})\n\napp.listen(\"3000\", () => {\n    console.log(\"listening at port 3000\");\n})\n\n现在接口地址是3000端口， 访问3000时，会返回data\n\n现在有个需求，需要访问8001端口时，代理到3000端口上\n\n:8001 {\n    reverse_proxy http://localhost:3000\n}\n\n两三行解决，第一块是写的:8001加一个大括号， 即默认是localhost:8001, 大括号即是site block\n\n可以在同一个配置文件中写多个网站的配置代理\n\nreverse_proxy: 代理的指令\n\n> reverse_proxy /api/* http://localhost:3000\n\n即把所有的/api路由结尾的都代理到3000端口\n\n相比于之前的nginx，或者说webpack中的devServer配置代理的操作，都简化了不少\n\n添加自定义请求header\n\n:8001 {\n    header Custom-Header \"caddy-server\"\n    reverse_proxy http://localhost:3000\n}\n\n配置中自定义添加header指令，就能添加自定义请求头了\n\nheader Location http:// https://\n\n替换header中location  http为https\n\n静态文件服务\n\n:8001 {\n    file_server browse\n}\n\nfile_server是一个文件服务的指令， 加上browse, 就是文件列表可视化，搭一个简易的文件服务，美滋滋\n\nSPA 单页面应用\n\n:8001 {\n    header Custom-Header \"caddy-server\"\n    encode gzip\n    handle /api/* {\n        reverse_proxy http://localhost:3000\n    }\n\n    handle {\n\t\ttry_files {path} /index.html\n\t\tfile_server\n\t}\n}\n",
        "tags": null
    },
    {
        "uri": "/posts/2021/11/frp/",
        "title": "go Frp 工具使用",
        "content": "\nfrp使用\n\nfrp是golang开发的内网穿透工具，日常我们本地的服务由于公网ip不固定，外网无法访问，有了内网穿透工具，就可以很轻松的把我们的服务暴露给外网使用。\n\n下载\n\nhttps://github.com/fatedier/frp/releases\n\n这里我下载的是linux_amd64版本，根据自己需要下载\n\n使用\n\nfrp分为服务端和客户端\n\n> 解压后 frp + s 即 server \\\n> 解压后 frp + c 即 client\n\n其中.ini为配置文件\n\nfrps.ini\n\n[common]\nbind_port = 7000 # frp 服务端暴露端口\nvhosthttpport = 8099 # frp 客户端监听端口\n\nfrpc.ini\n\n[common]\ntls_enable = true # windows下客户端不能连接服务器问题\nserver_addr = your.remote.ip # 你的服务器ip\nserver_port = 7000 # 暴露端口\n\n[web]\ntype = http # 类型\nlocal_port = 8099 # 客户端端口\ncustom_domains = your.domain # 自定义域名\n\n我们在 客户端上起一个服务\n\nconst http = require('http')\n\nhttp.createServer(function(req, res){\n   res.writeHead(200, { 'content-type': 'application/json' })\n   res.end(JSON.stringify({\n      data: 'success',\n      code: 200\n   }))\n})\n.listen(8099, function() {\n    console.log(listening at port 8099)\n})\n\n在其他机器上访问 http://your.domain:8099 即可访问到原本本地的web服务\n\n加入到系统命令中\n\nsystemd目录为自动脚本， 即linux中 service 命令对应的脚本\n\n以frps为例\n\n把可执行脚本frp 移动到 /usr/bin目录下\n\n> $ mv ./frps /usr/bin\n\n创建frp配置目录， 把 frps.ini 移动到该目录下\n\n> $ mkdir /etc/frp && mv frps.ini /etc/frp\n\n把相关自动执行脚本移动到systemd/system目录下\n\n> $ cd systemd && mv frps*service /etc/systemd/system\n\n启动\n\n> $ service frps start\n",
        "tags": [
            "工具",
            "go"
        ]
    },
    {
        "uri": "",
        "content": "�PNG\r\n\u001a\n\u0000\u0000\u0000\rIHDR\u0000\u0000\u0003�\u0000\u0000\u0000�\b\u0006\u0000\u0000\u0000\u001a�\u0001\u0016\u0000\u0000 \u0000IDATx���y\\���?��i�\u0016�P#�\u0010�ݍBʾd+�e,\u0019�X>a�\f\u0006c\u001a�2�\u0018ˌu�[�,!��P�!T�6�RR:����\\�?���t���\u0012������辯���s��������\u00161�\u0018\b!�\u0010B\b!��\u001d��.\u0000!�\u0010B\b!���A\u0001!!�\u0010B\b!��)\n\b\t!�\u0010B\b!DMQ@H\b!�\u0010B\b!j�\u0002BB\b!�\u0010B\bQS\u0014\u0010~ ���8��>���[��\u0019]S�p��i���B�R��/�4+���\f��N��۹N�CYY\u0019jkkQ]]�3g�\u0000��N(//GCC\u0003\"\"\"���`�O�B�Y�f�׺)���\u000e\b!�}�v��o�\u0006\u0000�{i2f̘~��\u0012\u0011\u0011��ńp\u00181�\b�K��;����\u001fkmm\u0005�A�3��777#!!\u0001����h4�>}:\\]]�Z����C����?\u001a��l�t�WXX����Ac0qww\u001f0^�c:\u000f\u0013&L�x���\u001eJ�\u0012���f���݋��d��zL�6\r\u001e\u001e\u001e\u0016��A***������j�\u001d;\u0016���puu�J�bBhe�'c��uBAA\u0001\n\n\n�ݏ�üy��?�IN��]������zO!\u0004����鐜����\u0000��ߊ\u0015+\u0006������z\\�n��]�~�\u0004.%%\u0005\u0019\u0019\u0019X�t)�~�m�Ǟ/��\u0012eeery��:�\u000f\u0002��\t��eѢE��\u001f�8h\f&��hJDDDC��qG\u0018S\u0017���\u0012���~��J%�\u00108u�\u0014���\u0010\u001d\u001dm�����h�Oooo\u0000��s�,ޯ��A~~��Ե�ʕ+��@���\u0003\u0000�K�*++-֝:u\n@_�vo\u000b�`I��`0[6u#��/���@�&]�����\u0001=}L�cnn�ף��1//\u000f������7k���N�|\u0018>>>��8{�ly~��˗��w�Ell,\u0002\u0003\u0003��ىK�.���ߢ5pӦM���Ç\u001f~�Ç\u000fcܸqr\u000b��\u0005\u000b�\u0012MS\fk֬��mې���g�}\u0016===�p�\u0002�F�ټ�DDD��0!\u001c\u0006>\u001e\u0013&L@ff��\b&%%���������(�]�h\u0011",
        "tags": []
    },
    {
        "uri": "/posts/2022/06/mp3-data-struct/",
        "title": "mp3 数据结构",
        "content": "\nmp3数据结构\n\nMP3文件大体上分为三个部分：ID3V2 + 音频数据 + ID3V1\n\nid3v1\n\nid3v1固定128个byte，以tag字符开头\n\nid3v2\n\nB[0:2]\t标识头，必须为“ID3”\nB[3]\t版本号，ID3V2.3 就记录3\nB[4]\t副版本号，此版本记录为0\nB[5]\t标志字节，一般为0，只使用高三位，其它位为0\n\t\t\ta：表示是否使用Unsynchronisation；\n\t\t\tb：表示是否有扩展头部，一般没有，所以一般也不设置；\n\t\t\tc：表示是否为测试标签，99.99%的标签都不是测试标签，不设置\nB[6:9]\t标签大小，共四个字节，每个字节只使用低7位，最高位不使用恒为0，计算时将最高位去掉，得到28bit的数据，计算公式如下：Size=(Size[0]&0x7F)0x200000+(Size[1]&0x7F)0x400+(Size[2]&0x7F)*0x80+(Size[3]&0x7F)\n\nmp3 frame\n\n数据帧结构\n\n| 4字节帧头 | 2字节可选CRC,取决于帧头的第16位 | 32字节通道信息 | 声音数据 |\n| --------- | ------------------------------- | -------------- | -------- |\n|           |                                 |                |          |\n\n4个字节帧头\n",
        "tags": [
            "mp3"
        ]
    },
    {
        "uri": "/posts/2022/05/ts-generics/",
        "title": "typescript 泛型类型",
        "content": "\nPartial\n\n可选类型, 把原本必选的参数都改成可选参数\n\ninterface Crew {\n  age: number;\n  name: string;\n}\n\nconst Jerry:Crew = {\n    age: 10,\n    name: 'jack'\n};\n\ntype AnonymousPeople = Partial;\n\nconst tom: AnonymousPeople = {\n    name: 'Tom'\n};\n\nkeyof\n\nkeyof用于获取对象的key\n\ntype Point = {\n  x: number;\n  y: number;\n}\n\ntype KPoint = keyof Point; // x | y\n\ntypeof\n\nconst point = {\na : 1,\nb: 'test'\n}\ntype P = keyof typeof point; // type '\"a\" || \"b\"'\n\nconst coordinate: P = 'z' // Type '\"z\"' is not assignable to type '\"a\" | \"b\"'.\n\ninfer\n\n推断返回类型\n\nconst add = (x: number, y: number) => x + y\ntype D = ReturnType // number\n\ntype ReturnType any> = T extends (...args: any) => infer R ? R : any\n\n> infer 的作用是让 TypeScript 自己推断，并将推断的结果存储到一个类型变量中，infer 只能用于 extends 语句中。\n\nextends\n\n条件类型是一种由条件表达式所决定的类型\n\n条件类型使类型具有了不唯一性，增加了灵活性\n\n> T extends U ? X : Y\n\n若类型T可以被赋值给类型U， 则返回X， 否则返回Y\n\n> A extends B\n\nA是B的超集，A包括B所有的属性，甚至更多\n\nA extends B is a lot like ‘A is a superset of B’, or, to be more verbose, ‘A has all of B’s properties, and maybe some more’.\n\nany & unknown\n\n顶层类型\n\nany:  绕过类型检查，直接可用\nunknown： 必须判断类型才能使用\n\nnever & void\n\nnever： 任何类型都不赋值， 只能是never\nvoid： 可以被赋值的类型\n\n类型约束\n\ntype MyType = T extends { message: any } ? T[\"message\"] : never\n\n内置类型函数\n\n// Exclude null and undefined from T\n// 判断是否为undefined\ntype NonNullable =\n  T extends null | undefined ? never : T\n\n// Obtain the parameters of a function type in a tuple\n// 类型判断\ntype Parameters =\n  T extends (...args: infer P) => any ? P : never\n\n// Obtain the parameters of a constructor function type in a tuple\ntype ConstructorParameters =\n  T extends new (...args: infer P) => any ? P : never\n\n// Obtain the return type of a function type\n// 返回值推断\ntype ReturnType =\n  T extends (...args: any[]) => infer R ? R : any\n\n// Obtain the return type of a constructor function type\n//\ntype InstanceType =\n  T extends new (...args: any[]) => infer R ? R : any\n\n示例\n\ntype Action =\n  {\n    type: \"INIT\"\n  }\n  | {\n    type: \"SYNC\"\n  }\n  | {\n    type: \"LOG_IN\"\n    emailAddress: string\n  }\n  | {\n    type: \"LOGINSUCCESS\"\n    accessToken: string\n  }\n\ntype ActionType = Action[\"type\"]\n\ntype ExcludeTypeKey = T extends \"type\" ? never : T\n\ntype ExcludeTypeArguments = A extends { type: T }\n  ? {\n    [k in Exclude]: A[k]\n  }\n  : never\n\nfunction dispatch(type: T, args: ExcludeTypeArguments) {\n\n}\n\ndispatch(\"LOG_IN\", {\n  emailAddress: '123'\n})\n\ndispatch(\"INIT\", {})\n\n引用\n\nhttps://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/",
        "tags": [
            "typescript"
        ]
    },
    {
        "uri": "/posts/2022/05/base-source/",
        "title": "源码解析",
        "content": "\nvite\n\nresolveConfig\n\n找到vite对应的config文件，并且判断config文件类型，是否是ts文件还是mjs文件\n通过esbuild去解析config文件中对应的代码，并且生成对应的文件保存到磁盘上",
        "tags": [
            "vite"
        ]
    },
    {
        "uri": "/posts/2022/06/client-overlay/",
        "title": "vite -- 客户端错误弹窗展示",
        "content": "\nVite client overlay\n\n利用Custom Component中的自定义组件，封装了一个自定义的web 标签\n\nexport const overlayId = 'vite-error-overlay'\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay)\n}\n\n实例化方法\n\n// 建立标签的根元素\nthis.root = this.attachShadow({ mode: 'open' })\n// 根元素上添加对应的html\nthis.root.innerHTML = template\n\ncodeframeRE.lastIndex = 0\nconst hasFrame = err.frame && codeframeRE.test(err.frame)\nconst message = hasFrame\n  ? err.message.replace(codeframeRE, '')\n  : err.message\n// 插件的错误展示\nif (err.plugin) {\n  this.text('.plugin', [plugin:${err.plugin}] )\n}\n// 写入错误正文\nthis.text('.message-body', message.trim())\n\nconst [file] = (err.loc?.file || err.id || 'unknown file').split(?)\n// 获取对应的文件\nif (err.loc) {\n  this.text('.file', ${file}:${err.loc.line}:${err.loc.column}, true)\n} else if (err.id) {\n  this.text('.file', file)\n}\n\nif (hasFrame) {\n  this.text('.frame', err.frame!.trim())\n}\n// 错误堆栈信息\nthis.text('.stack', err.stack, true)\n\n// 取消错误的点击冒泡\nthis.root.querySelector('.window')!.addEventListener('click', (e) => {\n  e.stopPropagation()\n})\n// 关闭事件\nthis.addEventListener('click', () => {\n  this.close()\n})\n\ntext\n\n此方法是用来找到对应的节点，并且链接到对应的文件\n\ntext(selector: string, text: string, linkFiles = false): void {\n  // 找到对应元素\n  const el = this.root.querySelector(selector)!\n  if (!linkFiles) {\n    el.textContent = text\n  } else {\n    let curIndex = 0\n    let match: RegExpExecArray | null\n    // 循环匹配文件正则，找到匹配的文件\n    while ((match = fileRE.exec(text))) {\n      const { 0: file, index } = match\n      if (index != null) {\n        const frag = text.slice(curIndex, index)\n        // 插入文本节点\n        el.appendChild(document.createTextNode(frag))\n        const link = document.createElement('a')\n        link.textContent = file\n        link.className = 'file-link'\n        link.onclick = () => {\n          // 跳转到指定文件\n          fetch('/__open-in-editor?file=' + encodeURIComponent(file))\n        }\n        // 插入链接节点\n        el.appendChild(link)\n        curIndex += frag.length + file.length\n      }\n    }\n  }\n}\n",
        "tags": [
            "vite",
            "client"
        ]
    },
    {
        "uri": "/posts/2022/06/client/",
        "title": "vite Client客户端源码",
        "content": "\nvite Client客户端源码\n\nvite 客户端使用来响应服务端文件改动， 最终客户端的代码通过注入的方向，注入到index.html中，实现热更新功能\n\n首先客户端和服务端通信使用的是websocket功能实现双向通信\n\n相关WebSocket的源码\n\nlet socket: WebSocket\ntry {\n  socket = new WebSocket(${socketProtocol}://${socketHost}, 'vite-hmr')\n\n  // Listen for messages\n  socket.addEventListener('message', async ({ data }) => {\n    handleMessage(JSON.parse(data))\n  })\n\n  // ping server\n  socket.addEventListener('close', async ({ wasClean }) => {\n    if (wasClean) return\n    console.log([vite] server connection lost. polling for restart...)\n    await waitForSuccessfulPing()\n    location.reload()\n  })\n} catch (error) {\n  console.error([vite] failed to connect to websocket (${error}). )\n}\n\nhandleMessage\n\n响应socket信息时，使用一个switch来区分不同类型的消息\n\n包括以下几种\n\n连接\n更新\n自定义\n完全更新\n错误处理\n\nasync function handleMessage(payload: HMRPayload) {\n  switch (payload.type) {\n    case 'connected':\n      console.debug([vite] connected.)\n      // ...\n      break\n    case 'update':\n      // ....\n      break\n    case 'custom': {\n      // ....\n      break\n    }\n    case 'full-reload':\n      // ...\n      break\n    case 'prune':\n      // ....\n      break\n    case 'error': {\n      // ...\n      break\n    }\n    default: {\n      const check: never = payload\n      return check\n    }\n  }\n}\n\nfull-reload\n\n完全更新的情况\n\n其实就是调用window.location.reload()方法实现页面刷新\n\nif (payload.path && payload.path.endsWith('.html')) {\n  // if html file is edited, only reload the page if the browser is\n  // currently on that page.\n  const pagePath = decodeURI(location.pathname)\n  const payloadPath = base + payload.path.slice(1)\n  if (\n    pagePath === payloadPath ||\n    payload.path === '/index.html' ||\n    (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)\n  ) {\n    location.reload()\n  }\n  return\n} else {\n  location.reload()\n}\n\nupdate\n\n部分更新的情况\n\njs更新，走queueUpdate\n其他资源更新，走else\n\npayload.updates.forEach((update) => {\n  if (update.type === 'js-update') {\n    queueUpdate(fetchUpdate(update))\n  } else {\n    // css-update\n    // this is only sent when a css file referenced with  is updated\n    const { path, timestamp } = update\n    const searchUrl = cleanUrl(path)\n    // can't use querySelector with [href*=] here since the link may be\n    // using relative paths so we need to use link.href to grab the full\n    // URL for the include check.\n    const el = Array.from(\n      document.querySelectorAll('link')\n    ).find((e) => cleanUrl(e.href).includes(searchUrl))\n    if (el) {\n      const newPath = `${base}${searchUrl.slice(1)}${\n        searchUrl.includes('?') ? '&' : '?'\n      }t=${timestamp}`\n\n      // rather than swapping the href on the existing tag, we will\n      // create a new link tag. Once the new stylesheet has loaded we\n      // will remove the existing link tag. This removes a Flash Of\n      // Unstyled Content that can occur when swapping out the tag href\n      // directly, as the new stylesheet has not yet been loaded.\n      const newLinkTag = el.cloneNode() as HTMLLinkElement\n      newLinkTag.href = new URL(newPath, el.href).href\n      const removeOldEl = () => el.remove()\n      newLinkTag.addEventListener('load', removeOldEl)\n      newLinkTag.addEventListener('error', removeOldEl)\n      el.after(newLinkTag)\n    }\n    console.log([vite] css hot updated: ${searchUrl})\n  }\n})\n\n其他资源更新的情况\n\n第一步，拿到所有的link元素，匹配出对应的元素\n第二步，对旧资源进行克隆，在加载到新资源的时候，再去删除旧的连接，保证页面的稳定\n\nqueueUpdate\n\n按队列更新信息\n\nasync function queueUpdate(p: Promise void) | undefined>) {\n  queued.push(p)\n  if (!pending) {\n    pending = true\n    await Promise.resolve()\n    pending = false\n    const loading = [...queued]\n    queued = []\n    ;(await Promise.all(loading)).forEach((fn) => fn && fn())\n  }\n}\n\n队列更新放到下一次微任务执行完毕后，通过promise.all方法清空队列数据\n\nfetchUpdate\n\n获取更新数据\n\nasync function fetchUpdate({ path, acceptedPath, timestamp }: Update) {\n  // 获取热更新模块\n  const mod = hotModulesMap.get(path)\n  // 不存在，则推出\n  if (!mod) {\n    // In a code-splitting project,\n    // it is common that the hot-updating module is not loaded yet.\n    // https://github.com/vitejs/vite/issues/721\n    return\n  }\n\n  // 模块容器\n  const moduleMap = new Map()\n  const isSelfUpdate = path === acceptedPath\n\n  // make sure we only import each dep once\n  const modulesToUpdate = new Set()\n  if (isSelfUpdate) {\n    // self update - only update self\n    // 自身更新\n    modulesToUpdate.add(path)\n  } else {\n    // dep update\n    // 更新依赖\n    for (const { deps } of mod.callbacks) {\n      // 循环更新依赖\n      deps.forEach((dep) => {\n        if (acceptedPath === dep) {\n          modulesToUpdate.add(dep)\n        }\n      })\n    }\n  }\n\n  // determine the qualified callbacks before we re-import the modules\n  const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => {\n    return deps.some((dep) => modulesToUpdate.has(dep))\n  })\n\n  // promise.all 更新数据\n  await Promise.all(\n    Array.from(modulesToUpdate).map(async (dep) => {\n      const disposer = disposeMap.get(dep)\n      if (disposer) await disposer(dataMap.get(dep))\n      const [path, query] = dep.split(?)\n      try {\n        // 获取新的模块数据\n        const newMod = await import(\n          /* @vite-ignore */\n          base +\n            path.slice(1) +\n            ?import&t=${timestamp}${query ? &${query} : ''}\n        )\n        // 添加到模块容器中\n        moduleMap.set(dep, newMod)\n      } catch (e) {\n        warnFailedFetch(e, dep)\n      }\n    })\n  )\n\n  return () => {\n    for (const { deps, fn } of qualifiedCallbacks) {\n      fn(deps.map((dep) => moduleMap.get(dep)))\n    }\n    const loggedPath = isSelfUpdate ? path : ${acceptedPath} via ${path}\n    console.log([vite] hot updated: ${loggedPath})\n  }\n}\n",
        "tags": [
            "vite",
            "client"
        ]
    },
    {
        "uri": "/posts/2022/06/env-usage/",
        "title": "vite中env环境变量使用",
        "content": "\nvite中env环境变量使用\n\n>   \"version\": \"3.0.0-alpha.9\"\n\nvite中可以通过loadEnv函数去读取指定环境变量文件，可以方便在vite配置文件中动态的导入到配置中\n\nimport { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ command, mode }) => {\n  // Load env file based on mode in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the VITE_ prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      APPENV: env.APPENV\n    }\n  }\n})\n\n源码路径\n\npackages/vite/src/node/env.ts\n\n默认会读取这4种类型的文件，都是以.env开头的， 其中后面的文件内容会覆盖前面的文件\n\n  const envFiles = [\n    /* mode local file / .env.${mode}.local,\n    /* mode file / .env.${mode},\n    /* local file / .env.local,\n    /* default file / .env\n  ]\n\n声明一个空变量env，作为最后返回的结果\n\n遍历process.env上的变量，写入到变量env上\n\n        for (const key in process.env) {\n       if (\n         prefixes.some((prefix) => key.startsWith(prefix)) &&\n         env[key] === undefined\n       ) {\n         env[key] = process.env[key] as string\n       }\n     }\n\n遍历读取配置文件上的数据，并且写到环境变量中\n\n   读取到单个文件的路径，并根据路径拿到文件内容\n   使用dotenv这个第三方包解析\n   使用dotenv-expand写入到系统环境变量上\n   把值写到变量env\n   返回env\n\nfor (const file of envFiles) {\n    const path = lookupFile(envDir, [file], { pathOnly: true, rootDir: envDir })\n    if (path) {\n      const parsed = dotenv.parse(fs.readFileSync(path), {\n        debug: process.env.DEBUG?.includes('vite:dotenv') || undefined\n      })\n\n      // let environment variables use each other\n      dotenvExpand({\n        parsed,\n        // prevent process.env mutation\n        ignoreProcessEnv: true\n      } as any)\n\n      // only keys that start with prefix are exposed to client\n      for (const [key, value] of Object.entries(parsed)) {\n        if (\n          prefixes.some((prefix) => key.startsWith(prefix)) &&\n          env[key] === undefined\n        ) {\n          env[key] = value\n        } else if (\n          key === 'NODE_ENV' &&\n          process.env.VITEUSERNODE_ENV === undefined\n        ) {\n          // NODE_ENV override in .env file\n          process.env.VITEUSERNODE_ENV = value\n        }\n      }\n    }\n  }\n",
        "tags": [
            "vite",
            "env"
        ]
    },
    {
        "uri": "/posts/2022/06/hmr-sourcecode/",
        "title": "vite--hmr热更新源码解读",
        "content": "\nvite hmr热更新源码\n\nvite中在文件发生改动时，server端会监听文件的变化，当文件发生变化会通知客户端重新发起请求，重新渲染页面\n\n源码位置\n\n>   \"version\": \"3.0.0-alpha.9\"\n\npackages/vite/src/node/server/hmr.ts\n\nhandleHMRUpdate\n\n热更新主入口函数\n\n文件类型判断\n\n判断更新的文件类型是什么文件，如果是配置文件就会重新启动服务\n\n\tconst shortFile = getShortName(file, config.root)\n  const fileName = path.basename(file)\n\n  const isConfig = file === config.configFile\n  const isConfigDependency = config.configFileDependencies.some(\n    (name) => file === name\n  )\n  const isEnv =\n    config.inlineConfig.envFile !== false &&\n    (fileName === '.env' || fileName.startsWith('.env.'))\n  // 配置文件\n  if (isConfig || isConfigDependency || isEnv) {\n    // auto restart server\n    debugHmr([config change] ${colors.dim(shortFile)})\n    config.logger.info(\n      colors.green(\n        ${path.relative(process.cwd(), file)} changed, restarting server...\n      ),\n      { clear: true, timestamp: true }\n    )\n    try {\n      // 重新启动\n      await server.restart()\n    } catch (e) {\n      config.logger.error(colors.red(e))\n    }\n    return\n  }\n\n构造上下文\n\n构造出热更新上下文\n\n  const hmrContext: HmrContext = {\n    file,\n    timestamp,\n    modules: mods ? [...mods] : [],\n    read: () => readModifiedFile(file),\n    server\n  }\n\nTips: 热更新的时候，vite官方之前是直接读取变化的文件，会发生有些时候读取时间过早读不到内容的情况，所以用了一个定时轮训的方式，读取文件变化的时间modified time,只要文件修改时间发生变化就返回出文件内容buffer\n\nasync function readModifiedFile(file: string): Promise {\n  const content = fs.readFileSync(file, 'utf-8')\n  if (!content) {\n    const mtime = fs.statSync(file).mtimeMs\n    await new Promise((r) => {\n      let n = 0\n      const poll = async () => {\n        n++\n        const newMtime = fs.statSync(file).mtimeMs\n        if (newMtime !== mtime || n > 10) {\n          r(0)\n        } else {\n          setTimeout(poll, 10)\n        }\n      }\n      setTimeout(poll, 10)\n    })\n    return fs.readFileSync(file, 'utf-8')\n  } else {\n    return content\n  }\n}\n\n响应插件的热更新\n\n这里会进行过滤需要更新的模块，提高更新的效率，避免全量更新\n\n  for (const plugin of config.plugins) {\n    if (plugin.handleHotUpdate) {\n      const filteredModules = await plugin.handleHotUpdate(hmrContext)\n      // 这里会进行过滤需要更新的模块，提高更新的效率，避免全量更新\n      if (filteredModules) {\n        hmrContext.modules = filteredModules\n      }\n    }\n  }\n\n如果文件是html，直接走全量更新\n\n if (file.endsWith('.html')) {\n    config.logger.info(colors.green(page reload ) + colors.dim(shortFile), {\n      clear: true,\n      timestamp: true\n    })\n    ws.send({\n      type: 'full-reload',\n      path: config.server.middlewareMode\n        ? '*'\n        : '/' + normalizePath(path.relative(config.root, file))\n    })\n  }\n\n最后走到updateModules\n\nupdateModules\n\n对模块进行遍历\n\n校验模块的有效性\n每个模块进行更新边界整理，就是走propagateUpdate方法\n整体搜集放入到updates数组中，最后通过websocket返回给前端\n\n\tconst updates: Update[] = []\n  const invalidatedModules = new Set()\n  let needFullReload = false\n\n  for (const mod of modules) {\n    invalidate(mod, timestamp, invalidatedModules)\n    if (needFullReload) {\n      continue\n    }\n\n    const boundaries = new Set()\n    const hasDeadEnd = propagateUpdate(mod, boundaries)\n    if (hasDeadEnd) {\n      needFullReload = true\n      continue\n    }\n\n    updates.push(\n      ...[...boundaries].map(({ boundary, acceptedVia }) => ({\n        type: ${boundary.type}-update as Update['type'],\n        timestamp,\n        path: boundary.url,\n        acceptedPath: acceptedVia.url\n      }))\n    )\n  }\n\n通知更新\n\n// 全量更新\nif (needFullReload) {\n  ws.send({\n    type: 'full-reload'\n  })\n} else {\n  // 范围更新\n  ws.send({\n    type: 'update',\n    updates\n  })\n}\n\npropagateUpdate\n\n> time to update\n",
        "tags": [
            "hmr"
        ]
    },
    {
        "uri": "/posts/2022/06/modulegraph-sourcecode/",
        "title": "vite ModuleGraph源码解读",
        "content": "\nVite -- moduleGraph源码解读\n\nvite中使用moduleGraph去记录模块之间的引用关系\n\n源码位置\n\npackages/vite/src/node/server/moduleGraph.ts\n\n>   \"version\": \"3.0.0-alpha.9\"\n\nModuleNode\n\nModuleNode是moduleGraph中的最小颗粒，每个模块都会用一个node去表示，其中每个node中都记录了当前模块的所有信息，包括编译之后的结果\n\nclass ModuleNode {\n  /**\n   Public served url path, starts with /\n   */\n  url: string\n  /**\n   Resolved file system path + query\n   */\n  id: string | null = null\n  file: string | null = null\n  type: 'js' | 'css'\n  info?: ModuleInfo\n  meta?: Record\n  importers = new Set()\n  importedModules = new Set()\n  acceptedHmrDeps = new Set()\n  isSelfAccepting?: boolean\n  transformResult: TransformResult | null = null\n  ssrTransformResult: TransformResult | null = null\n  ssrModule: Record | null = null\n  ssrError: Error | null = null\n  lastHMRTimestamp = 0\n  lastInvalidationTimestamp = 0\n\n  constructor(url: string) {\n    this.url = url\n    this.type = isDirectCSSRequest(url) ? 'css' : 'js'\n    // #7870\n    // The isSelfAccepting value is set by importAnalysis, but some\n    // assets don't go through importAnalysis.\n    if (isHTMLRequest(url) || canSkipImportAnalysis(url)) {\n      this.isSelfAccepting = false\n    }\n  }\n}\n\nModuleGraph\n\n模块依赖容器类\n\n容器类有4个属性，分别用来记录url、id、文件和模块之间的对应关系\n\n  urlToModuleMap = new Map()\n  idToModuleMap = new Map()\n  // a single file may corresponds to multiple modules with different queries\n  fileToModulesMap = new Map>()\n  safeModulesPath = new Set()\n\nconstructor\n\n构造函数，这里从实例外部传入了一个resolveId函数，把解析id的能力留到外部去做\n\nconstructor(\n    private resolveId: (\n      url: string,\n      ssr: boolean\n    ) => Promise\n  ) {}\n\nresolveUrl\n\n解析url参数\n\n去除url后面的查询参数，保证url最终指向的是同一个模块\n上下文推断可以知道，this.resolveId 最终肯定是个对象，有个id属性\n用node.extname去解析出扩展名\n用url.parseUrl解析url\n把url处理成统一格式并返回\n\n  // for incoming urls, it is important to:\n  // 1. remove the HMR timestamp query (?t=xxxx)\n  // 2. resolve its extension so that urls with or without extension all map to\n  // the same module\n  async resolveUrl(url: string, ssr?: boolean): Promise {\n    url = removeImportQuery(removeTimestampQuery(url))\n    const resolved = await this.resolveId(url, !!ssr)\n    const resolvedId = resolved?.id || url\n    const ext = extname(cleanUrl(resolvedId))\n    const { pathname, search, hash } = parseUrl(url)\n    if (ext && !pathname!.endsWith(ext)) {\n      url = pathname + ext + (search || '') + (hash || '')\n    }\n    return [url, resolvedId, resolved?.meta]\n  }\n\nensureEntryFromUrl\n\n解析url拿到对应的属性\n\n添加到对应的urlToModuleMap、idToModuleMap、fileToModulesMap中，便于后续更新\n\n  async ensureEntryFromUrl(rawUrl: string, ssr?: boolean): Promise {\n    const [url, resolvedId, meta] = await this.resolveUrl(rawUrl, ssr)\n    let mod = this.urlToModuleMap.get(url)\n    if (!mod) {\n      // 模块不存在，记录依赖关系\n      mod = new ModuleNode(url)\n      if (meta) mod.meta = meta\n      this.urlToModuleMap.set(url, mod)\n      mod.id = resolvedId\n      this.idToModuleMap.set(resolvedId, mod)\n      const file = (mod.file = cleanUrl(resolvedId))\n      let fileMappedModules = this.fileToModulesMap.get(file)\n      if (!fileMappedModules) {\n        fileMappedModules = new Set()\n        this.fileToModulesMap.set(file, fileMappedModules)\n      }\n      fileMappedModules.add(mod)\n    }\n    return mod\n  }\n\nupdateModuleInfo\n\n用于更新模块之间依赖信息的\n\n/**\n   Update the module graph based on a module's updated imports information\n   If there are dependencies that no longer have any importers, they are\n   returned as a Set.\n   */\n  async updateModuleInfo(\n    mod: ModuleNode,\n    importedModules: Set,\n    acceptedModules: Set,\n    isSelfAccepting: boolean,\n    ssr?: boolean\n  ): Promise | undefined> {\n    mod.isSelfAccepting = isSelfAccepting\n    // 之前的引入的依赖\n    const prevImports = mod.importedModules\n    // 重置依赖为一个set\n    const nextImports = (mod.importedModules = new Set())\n    // 这个变量用于保存那些不再有任何依赖的模块\n    let noLongerImported: Set | undefined\n    // update import graph\n    for (const imported of importedModules) {\n      const dep =\n        typeof imported === 'string'\n\t\t      // 依赖是个字符串的时候，都会再去走一下获取文件的逻辑\n          ? await this.ensureEntryFromUrl(imported, ssr)\n          : imported\n      // 加入到模块的importers中去\n      dep.importers.add(mod)\n\n      nextImports.add(dep)\n    }\n    // remove the importer from deps that were imported but no longer are.\n    prevImports.forEach((dep) => {\n      // 比对，新模块中没有就删除掉\n      if (!nextImports.has(dep)) {\n        dep.importers.delete(mod)\n        if (!dep.importers.size) {\n          // 加入到0依赖的set中\n          // dependency no longer imported\n          ;(noLongerImported || (noLongerImported = new Set())).add(dep)\n        }\n      }\n    })\n    // update accepted hmr deps\n    // 遍历加入到模块acceptedHmrDeps队列中\n    const deps = (mod.acceptedHmrDeps = new Set())\n    for (const accepted of acceptedModules) {\n      const dep =\n        typeof accepted === 'string'\n          ? await this.ensureEntryFromUrl(accepted, ssr)\n          : accepted\n      deps.add(dep)\n    }\n    return noLongerImported\n  }\n\ncreateFileOnlyEntry\n\n用于解决只记录文件依赖属性的文件， 类型于引入的css需要实现热更新\n\n  createFileOnlyEntry(file: string): ModuleNode {\n    file = normalizePath(file)\n    let fileMappedModules = this.fileToModulesMap.get(file)\n    if (!fileMappedModules) {\n      fileMappedModules = new Set()\n      this.fileToModulesMap.set(file, fileMappedModules)\n    }\n\n    const url = ${FS_PREFIX}${file}\n    for (const m of fileMappedModules) {\n      if (m.url === url || m.id === file) {\n        return m\n      }\n    }\n\n    const mod = new ModuleNode(url)\n    mod.file = file\n    fileMappedModules.add(mod)\n    return mod\n  }\n",
        "tags": [
            "websocket"
        ]
    },
    {
        "uri": "/posts/2022/05/open-browser-principle/",
        "title": "vite -- 打开浏览器原理",
        "content": "\nvite  -- open browser\n\n>   \"version\": \"3.0.0-alpha.9\"\n\nopen\n\nopen是一个第三方开发的开源库，用于在命令行打开浏览器，本身已经对各个平台的的代码做了兼融，知识对外部暴露了api\n\n使用方式\n\nconst open = require('open');\n\n// Opens the image in the default image viewer and waits for the opened app to quit.\nawait open('unicorn.png', {wait: true});\nconsole.log('The image viewer app quit');\n\n// Opens the URL in the default browser.\nawait open('https://sindresorhus.com');\n\n// Opens the URL in a specified browser.\nawait open('https://sindresorhus.com', {app: {name: 'firefox'}});\n\n// Specify app arguments.\nawait open('https://sindresorhus.com', {app: {name: 'google chrome', arguments: ['--incognito']}});\n\n// Open an app\nawait open.openApp('xcode');\n\n// Open an app with arguments\nawait open.openApp(open.apps.chrome, {arguments: ['--incognito']});\n",
        "tags": [
            "vite",
            "open browser"
        ]
    },
    {
        "uri": "/posts/2022/06/plugin-container-sourcecode/",
        "title": "vite -- pluginContainer插件容器源码解读",
        "content": "\nVite 插件机制及实现原理\n\n>   \"version\": \"3.0.0-alpha.10\"\n\n源码位置\n\npackages/vite/src/node/server/pluginContainer.ts\n\n整个文件只有一个函数，通过一个多达700行的函数，最终返回一个container对象\n\nexport async function createPluginContainer(\n  { plugins, logger, root, build: { rollupOptions } }: ResolvedConfig,\n  moduleGraph?: ModuleGraph,\n  watcher?: FSWatcher\n): Promise {\n\t// ....\n\tconst conatiner = {\n    //....\n  }\n  return container;\n}\n\ncontainer\n\n代码太长，跳过一些影响阅读的部分，看结尾container返回了什么\n\noptions\n\n一个自执行函数， 遍历全部plugins，如果有options参数，就执行一次，这里也能看到插件的options需要是一个promise函数\n\ngetModuleInfo\n\n获取模块信息，其实走的是moduleGraph那个实例内的方法\n\nbuildStart\n\n通过promise.all等待所有插件的buildStart方法执行完毕， 插件传入了一个Context实例，下面再看\n\nresolveId\n\n遍历全部插件，这里ctx其实就是Context实例对象\n\nlet id: string | null = null\nconst partial: Partial = {}\nfor (const plugin of plugins) {\n  if (!plugin.resolveId) continue\n  if (skip?.has(plugin)) continue\n\n  ctx._activePlugin = plugin\n\n  const pluginResolveStart = isDebug ? performance.now() : 0\n  const result = await plugin.resolveId.call(\n    ctx as any,\n    rawId,\n    importer,\n    { ssr, scan }\n  )\n  if (!result) continue\n\n  if (typeof result === 'string') {\n    id = result\n  } else {\n    id = result.id\n    Object.assign(partial, result)\n  }\n\n  // resolveId() is hookFirst - first non-null result is returned.\n  break\n}\n\nload\n\n循环调用插件的load方法，如有返回，就会去更新模块相关信息\n\nasync load(id, options) {\n    const ssr = options?.ssr\n    const ctx = new Context()\n    ctx.ssr = !!ssr\n    for (const plugin of plugins) {\n      if (!plugin.load) continue\n      ctx._activePlugin = plugin\n      const result = await plugin.load.call(ctx as any, id, { ssr })\n      if (result != null) {\n        if (isObject(result)) {\n          updateModuleInfo(id, result)\n        }\n        return result\n      }\n    }\n    return null\n},\n\ntransform\n\n插件的转换方法，具体的编译应该就是在这个阶段完成的，最终返回的是转换后的代码和代码的sourcemap\n\nasync transform(code, id, options) {\n    const inMap = options?.inMap\n    const ssr = options?.ssr\n    const ctx = new TransformContext(id, code, inMap as SourceMap)\n    ctx.ssr = !!ssr\n    for (const plugin of plugins) {\n      if (!plugin.transform) continue\n      ctx._activePlugin = plugin\n      ctx._activeId = id\n      ctx._activeCode = code\n      const start = isDebug ? performance.now() : 0\n      let result: TransformResult | string | undefined\n      try {\n        // 调用插件的transform方法进行转换\n        result = await plugin.transform.call(ctx as any, code, id, { ssr })\n      } catch (e) {\n        ctx.error(e)\n      }\n      if (!result) continue\n      // 。。。\n      if (isObject(result)) {\n        if (result.code !== undefined) {\n          // 转换结果是一个对象，切有.code属性\n          code = result.code\n          if (result.map) {\n            if (isDebugSourcemapCombineFocused) {\n              // @ts-expect-error inject plugin name for debug purpose\n              result.map.name = plugin.name\n            }\n            ctx.sourcemapChain.push(result.map)\n          }\n        }\n        updateModuleInfo(id, result)\n      } else {\n        code = result\n      }\n    }\n  \t//\n    return {\n      code,\n      map: ctx._getCombinedSourcemap()\n    }\n  },\n\nclose\n\nclose方法循环调用插件的buildEnd方法和closeBundle方法，最后置flag为true\n\nasync close() {\n      if (closed) return\n      const ctx = new Context()\n      await Promise.all(\n        plugins.map((p) => p.buildEnd && p.buildEnd.call(ctx as any))\n      )\n      await Promise.all(\n        plugins.map((p) => p.closeBundle && p.closeBundle.call(ctx as any))\n      )\n      closed = true\n}\n\ncontainer完整代码\n\nconst container: PluginContainer = {\n    options: await (async () => {\n      let options = rollupOptions\n      for (const plugin of plugins) {\n        if (!plugin.options) continue\n        options =\n          (await plugin.options.call(minimalContext, options)) || options\n      }\n      if (options.acornInjectPlugins) {\n        parser = acorn.Parser.extend(\n          ...(arraify(options.acornInjectPlugins) as any)\n        )\n      }\n      return {\n        acorn,\n        acornInjectPlugins: [],\n        ...options\n      }\n    })(),\n\n    getModuleInfo,\n\n    async buildStart() {\n      await Promise.all(\n        plugins.map((plugin) => {\n          if (plugin.buildStart) {\n            return plugin.buildStart.call(\n              new Context(plugin) as any,\n              container.options as NormalizedInputOptions\n            )\n          }\n        })\n      )\n    },\n\n    async resolveId(rawId, importer = join(root, 'index.html'), options) {\n      const skip = options?.skip\n      const ssr = options?.ssr\n      const scan = !!options?.scan\n      const ctx = new Context()\n      ctx.ssr = !!ssr\n      ctx._scan = scan\n      ctx._resolveSkips = skip\n      const resolveStart = isDebug ? performance.now() : 0\n\n      let id: string | null = null\n      const partial: Partial = {}\n      for (const plugin of plugins) {\n        if (!plugin.resolveId) continue\n        if (skip?.has(plugin)) continue\n\n        ctx._activePlugin = plugin\n\n        const pluginResolveStart = isDebug ? performance.now() : 0\n        const result = await plugin.resolveId.call(\n          ctx as any,\n          rawId,\n          importer,\n          { ssr, scan }\n        )\n        if (!result) continue\n\n        if (typeof result === 'string') {\n          id = result\n        } else {\n          id = result.id\n          Object.assign(partial, result)\n        }\n\n        isDebug &&\n          debugPluginResolve(\n            timeFrom(pluginResolveStart),\n            plugin.name,\n            prettifyUrl(id, root)\n          )\n\n        // resolveId() is hookFirst - first non-null result is returned.\n        break\n      }\n\n      if (isDebug && rawId !== id && !rawId.startsWith(FS_PREFIX)) {\n        const key = rawId + id\n        // avoid spamming\n        if (!seenResolves[key]) {\n          seenResolves[key] = true\n          debugResolve(\n            `${timeFrom(resolveStart)} ${colors.cyan(rawId)} -> ${colors.dim(\n              id\n            )}`\n          )\n        }\n      }\n\n      if (id) {\n        partial.id = isExternalUrl(id) ? id : normalizePath(id)\n        return partial as PartialResolvedId\n      } else {\n        return null\n      }\n    },\n\n    async load(id, options) {\n      const ssr = options?.ssr\n      const ctx = new Context()\n      ctx.ssr = !!ssr\n      for (const plugin of plugins) {\n        if (!plugin.load) continue\n        ctx._activePlugin = plugin\n        const result = await plugin.load.call(ctx as any, id, { ssr })\n        if (result != null) {\n          if (isObject(result)) {\n            updateModuleInfo(id, result)\n          }\n          return result\n        }\n      }\n      return null\n    },\n\n    async transform(code, id, options) {\n      const inMap = options?.inMap\n      const ssr = options?.ssr\n      const ctx = new TransformContext(id, code, inMap as SourceMap)\n      ctx.ssr = !!ssr\n      for (const plugin of plugins) {\n        if (!plugin.transform) continue\n        ctx._activePlugin = plugin\n        ctx._activeId = id\n        ctx._activeCode = code\n        const start = isDebug ? performance.now() : 0\n        let result: TransformResult | string | undefined\n        try {\n          result = await plugin.transform.call(ctx as any, code, id, { ssr })\n        } catch (e) {\n          ctx.error(e)\n        }\n        if (!result) continue\n        isDebug &&\n          debugPluginTransform(\n            timeFrom(start),\n            plugin.name,\n            prettifyUrl(id, root)\n          )\n        if (isObject(result)) {\n          if (result.code !== undefined) {\n            code = result.code\n            if (result.map) {\n              if (isDebugSourcemapCombineFocused) {\n                // @ts-expect-error inject plugin name for debug purpose\n                result.map.name = plugin.name\n              }\n              ctx.sourcemapChain.push(result.map)\n            }\n          }\n          updateModuleInfo(id, result)\n        } else {\n          code = result\n        }\n      }\n      return {\n        code,\n        map: ctx._getCombinedSourcemap()\n      }\n    },\n\n    async close() {\n      if (closed) return\n      const ctx = new Context()\n      await Promise.all(\n        plugins.map((p) => p.buildEnd && p.buildEnd.call(ctx as any))\n      )\n      await Promise.all(\n        plugins.map((p) => p.closeBundle && p.closeBundle.call(ctx as any))\n      )\n      closed = true\n    }\n  }\n\nclass Context\n\ncontext在vite的插件中至关重要，vite实现编译vue文件和react文件，背后都是依赖于插件机制，vite并不只是为vue开发使用，也可以实现插件用于别的地方\n\npluginContext 其实是继承于rollup的PluginContext，这也就是为什么vite可以使用部分rollup的插件的原因，不得不说这种实现真的很聪明，一下子就扩大了自己的插件生态\n\nacorn\n\n第三方npm包，用于javascript转换器\n\nhttps://github.com/acornjs/acorn.git\n\nclass Context implements PluginContext {\n    meta = minimalContext.meta\n    ssr = false\n    _scan = false\n    _activePlugin: Plugin | null\n    _activeId: string | null = null\n    _activeCode: string | null = null\n    _resolveSkips?: Set\n    _addedImports: Set | null = null\n\n    constructor(initialPlugin?: Plugin) {\n      this._activePlugin = initialPlugin || null\n    }\n\n  \t// 解析代码\n    parse(code: string, opts: any = {}) {\n      return parser.parse(code, {\n        sourceType: 'module',\n        ecmaVersion: 'latest',\n        locations: true,\n        ...opts\n      })\n    }\n\n    async resolve(\n      id: string,\n      importer?: string,\n      options?: { skipSelf?: boolean }\n    ) {\n      let skip: Set | undefined\n      if (options?.skipSelf && this._activePlugin) {\n        skip = new Set(this._resolveSkips)\n        skip.add(this._activePlugin)\n      }\n      let out = await container.resolveId(id, importer, {\n        skip,\n        ssr: this.ssr,\n        scan: this._scan\n      })\n      if (typeof out === 'string') out = { id: out }\n      return out as ResolvedId | null\n    }\n\n    getModuleInfo(id: string) {\n      return getModuleInfo(id)\n    }\n\n    getModuleIds() {\n      return moduleGraph\n        ? moduleGraph.idToModuleMap.keys()\n        : Array.prototypeSymbol.iterator\n    }\n\n    addWatchFile(id: string) {\n      watchFiles.add(id)\n      ;(this.addedImports || (this.addedImports = new Set())).add(id)\n      if (watcher) ensureWatchedFile(watcher, id, root)\n    }\n\n    getWatchFiles() {\n      return [...watchFiles]\n    }\n\n    emitFile(assetOrFile: EmittedFile) {\n      warnIncompatibleMethod(emitFile, this._activePlugin!.name)\n      return ''\n    }\n\n    setAssetSource() {\n      warnIncompatibleMethod(setAssetSource, this._activePlugin!.name)\n    }\n\n    getFileName() {\n      warnIncompatibleMethod(getFileName, this._activePlugin!.name)\n      return ''\n    }\n\n    warn(\n      e: string | RollupError,\n      position?: number | { column: number; line: number }\n    ) {\n      const err = formatError(e, position, this)\n      const msg = buildErrorMessage(\n        err,\n        [colors.yellow(warning: ${err.message})],\n        false\n      )\n      logger.warn(msg, {\n        clear: true,\n        timestamp: true\n      })\n    }\n\n    error(\n      e: string | RollupError,\n      position?: number | { column: number; line: number }\n    ): never {\n      // error thrown here is caught by the transform middleware and passed on\n      // the the error middleware.\n      throw formatError(e, position, this)\n    }\n  }\n\nplugin json\n\n以内置的json插件为例\n\nvite在引用json文件时会使用这个插件进行代码转换，可以看到就是把json文件在插件的transform方法中进行了进一步的包装\n\nexport function jsonPlugin(\n  options: JsonOptions = {},\n  isBuild: boolean\n): Plugin {\n  return {\n    name: 'vite:json',\n\n    transform(json, id) {\n      if (!jsonExtRE.test(id)) return null\n      if (SPECIALQUERYRE.test(id)) return null\n\n      try {\n        if (options.stringify) {\n          //....\n            return export default JSON.parse(${JSON.stringify(json)})\n        }\n\n        const parsed = JSON.parse(json)\n        return {\n          code: dataToEsm(parsed, {\n            preferConst: true,\n            namedExports: options.namedExports\n          }),\n          map: { mappings: '' }\n        }\n      } catch (e) {\n        //...\n      }\n    }\n  }\n}\n",
        "tags": [
            "vite",
            "plugin"
        ]
    },
    {
        "uri": "",
        "content": "�PNG\r\n\u001a\n\u0000\u0000\u0000\rIHDR\u0000\u0000\u0002�\u0000\u0000\u0004�sg#$�Sl4�t�?\r%\r�V4�����6n�I6�\"�d��Θ��83���OEP|1�\u0014Ŀ�� (�\u000f�>�/�\n%�� (>���P苦�;3�i���e�|��{�g�\u0005蹪X��\u0014\u0001\u0016��-\u00172�s���=+����\u0017\u0006�WQ\u001d+]�L\u00026O\u000bw�[�C�{_�������F\u001d\u0015 q\u001fb��\u000b��\u0001�U�v\u0001z��\u001f?�Z\u001e�b�1@�/z��c��s>~�if�,�ӈ\u0005USj��\u0010����F\f�1��_�Mj���b�uݠ�p�a��m�h��mçϙ�>��a\\�+5%��Q�K���F�\b�km}�\u001c�ۖ��\u0011?\u0006��ޚ��\u0011�D\\��\u0007�������!~�6�,�-��7��S�ث��Ŝ�vķ5Z��;\u0004���[���r�mS�����5��{yD���yH�}r�9��|��-\u0007�����\u0015ă��FA������J\u0010\u0003\u0019j\u001a�I.��\u000e[/�]m���K\f\u00177�\u001fK\u0016���R��D��r��Y\u0006�Q��O�-����Q��\u0017|�|�6���\r�\t\u0005(�0��\nMX\u0003\u0011d(@\u0006�\u0016�h��\u000e\u00062\u0014�\u0014\u0019�_�f\u0017\u001b���\u0016�\u001a���\u0016�e�\\c\u0013?~,7\u0002?&\u0019 \u0012ك�^2I��q2\u0001\"y�\u0000if�-�\u0004`)���r����m��n\u0018�����\u001a�?2���6�Xn4$69,�m���,�\u00143ܶf��-%�\u0015�Ŷ\u0015���W��ʬ|\f\"\"\"y��?\u0000�=��K׸r�\n�{�}\u0014\u0015\u0015J4*i���bƌ�\b\f\f�����\u0002�_�\u001eǎ\u001d�qdԘ��uk-l;3�-�\u000f�v��\u0016�\u0007`9p;\u0013�M��[Jb�f駖��F�;11�2\u00000p\u0013\u0011����4����$��͛7�d�\u0012\u0014\u0015\u0015Ir=)̙3\u0007�ڵs�\t\t\t�֭;v�څ۷�\u001c�삂�1k�L�h���k�����7�H\u001d�k�K\\��6\fצ��![,�[�\u0016%\u0016�]\u0019���sK��v�u'&&�\u0001I\"\"jp22��w���)SТE\u000b̜9\u0003K�,EYY������l,^�\u0018\u000f��p�9�l5x7�R��7o�}���~`` ���q����\u001a����\u0005��~K\u0013��4ib�ޤI\u0013���,���_w-��������{\u0013\u00115D���HI�av^���˗����������J�4�ZЖ�|D��\u000fM:�A������H(\u0014���V]]���|�c���r�h�Z-�Tu��MTU��6�p96)�Y�\u0016�??\u0001���\u000e�WTTlv,??\u001fW���;\u001d\u001c\u001c���P\u0000��\u0007�C��R�v�\u001a\u0016,X�g�}\u0006=z�@�6m����C������8|�0����T*�P(���\u001e=R���\u0002\u001f\u001f\u001f�:����ڵ����rHw\u0017�N�ֹ��\u000f�5k�ҵ\"\"�ހ��zv\ru\u000b�y{�\u0013�\u0010�j��t�p_i�m�Gie�h?11�n\u0001L;��\u001f\u0019\"\"\"[BC���K����i,[����11�x��\u0000\u0000\u0016,�\u0007�^\u0015\u000f��]��\u0003��SO��F��\u001b���P�[�n\u0018>|\u0018ڵkg�YgϞÆ\r\u001bp���F6>>*��/��\u001b\u0013G}��:��FR]]m�=;;�\u001d\u0000-�a[�Ƕ�ض�>L�\r�@d���1)f�ł�i���,]����^(((��\u001d;0x�`O\u000f�d�ñcGq��Q�i�\u0016w��\u0013�ڵC�6m�f�u:\u001d.\\����S8u*��E:ޢ�F�ի?\u0001`�L�^�\u000e�v2]�\u001b\"����.%\b�8K�ʫ�\u001d%�\u0013�DDD�������֭�����\b�ޥK\u0017q��E\u0000��␐\u0010��Ԡ��\u0006UUUN-B�n55\u001a|��j��?�=���j��&]�\u0017�8{}���-U\u0000�4��e\u0000���\u0001љ�eS�PS�A~~�\\O[��iLoM_nc�췳�1��:ܮ�d[!������U�2��Y�&9^|#֧^�Y�����\u001a,[y��|k7[��ٺkg�4C8\u0011\u0011\u0011\u0011�J�,�t����\u0019G�\u00044�Ǟe\u0001�&۵�\u0002fX\u001b�\u0018.\u000bHDDD�xر,`\u0002��3�jz�ڲ�����>�|u���\u0012[K�q\u0006�����>^�-6�\u0005\u0006\u000f\u001e,�?/��w����q�:�^���\n+W���0\u0000\u0000���\u0011g�\u0016��L�T�W^��ٳq��m�xHH\b�ϟo�����\u0013C$\"\"�\u0006���lJqr�\u000eoT�\u0014���?�y�\u001d�������hٲ%���\u001f�Wa�\u0018%��\u0002�Mq�_�\u001b7\n�IIIf�#F�\u0010�333QYY!�w�(l��梢��,��kWQ]]m�����F��\u0017��\u00193f 6���\u000f !�1��j|��j|\u0018=z�\u0000�_��G�\u001e�ѣ\u0007���q��U\u001c8p\u0010۷o�\u001a�]�u�V�\u001c����j5�\u000e\u001d��C����\f�.]�/�����4��o\"\"�Ƃ3�T������ԩSF}��뇈\b�>\u0013\u0011\u0011QC��M�Nx ��oJ���\nC�P\"�O��E\u001d^��}3�;w�\u0012��\u000f\u001f���\u0018\u0004\u0005�\u001f\u0016,..\u0016�Ѿz�n\u0015���(��\u000f\b\b\u0010^����[�裏𷿍7\n�]��?�)���\f,\\��l%\u0016�\u0007M���\u001a2\u0006n���F\u0003\u001fOUb�B�\u0010�����u�V�t\"99\tÆս���w���c�\u000ea[�Vc\t\u0016��`�����F�\u001e��_���_��޽������DVV�����D�_ll\u000b(\u0014�����\u0017^\u0010�`�\u0007���sF���\r�DDD�\u0001\u00037y�#\u0017uX�x`\u000e\u000b��3��\u001a�:VW\u001b�6\u001ah�B_�l�>��*++���\t@\u001f�SS\u0007\nm�6m\u0012=�ܹ�(--\u0013����?aРAF}�J\u001fL�8\t���V�߲eK$''!99\t�&MD������k�\u001eqqq�~�xk��\u0007`ժUX�t\t֮]�nݬ�J�T�Ν�1̙3\u0007~~~f}F��\u001f*U݂Hb\u000fX\u0012\u0011\u00115d\\\u0016���X��>l_�\u0005�\u0004\u0002��Y\u0017�S�*p�\u0014x��\u001a\u0000�ĕ5\u0018q�\u0012-������-��nz�{��\u001b7b�ԩ\u0000 ���ڵk(--�x�{ｋٳg\u000b�����SO�ʕ+P��\u0010\u001b\u001b#\\K��\u001a�\u0006�����ѧ�~f[�RaٲeHO?��웨�֠]��HL�[�[��b�\u0006��\u0007\u001f|P(�Q�Tx��q8v�ݟӦM\u00187n\u001c\u0000�Y�fX�j\u0015\u000e\u001d:���B��~�ԩ�Ѳ�yyy\f�DD��0p�W蟬����3�_�6����p}�\f\u000f\u0004�?���O���\u0000��ϸ��6\u0007\u000e\u001c�F�1��ݼy��s�\u001d;����\u001acƌ\u0011��T*�W�\u0003@QQ\u0011��~���cNN\u000e���\u001b�\u001a5\nJ�\u0012J�R�m6U^^��^{\ree�O���&b���-۷oG��݅W������;�\u0014�{��U��\u001f�9t}\"\"���%%�\u0015z�S�˹>F\u000fA��Q`�\u0018%�=^�����*��\u0002}�f��c�B��]\u0014�n�\u000fR�[gs�4\u001a\r\u0016-Z���\u001f���KĔ��bӦMx���\u0002?\u0011\u0011Qc�@�¼�_��M����\u0014ٶ�511�\u001f�Ơ�\u0001\u0000M7=���&�m\u0015��\u001f>n��Wk�R\u0013oִi(Z���V�C^^�\u001f\u000f9:7H$$$���\u0004gϞCU�}E�M�����P��o���P\u001f��\u0017_`���V��@\\\\\u001cڴi�k׮#33�o�$\"\"�\u0014>�/�\f��\u0001�����\u0013\u0001h��\u001f��_M���\u0003+�09Β\u0012\"O+,,��c\u0005�\\+//\u0017yy�N�A�B�Dddݺ����6��õkWq���h\u0012\u0011\u00115\u0016\f��\u0016\u0017��W\u0017q�=�y��\u0001\u00183f��C�gϞ�������'\u0006nr��Jԋ�\u000eқ2e��\u0002J���|њs\"\"\"��\u000fM\u0012�\u0019���h���\u001c�\u0017���\u0010\u0011\u0011�o��&\"3gΜFӦ!���AFF\u0006~�q\u0007\u001f~$\"\"r\u0012\u00037\u0011�ټy���H����^,)!\"\"\"\"�\u0011\u00037\u0011\u0011\u0011\u0011��\u0018������d��MDDDD$#\u0006n\"\"\"\"\"\u00191p\u0013\u0011\u0011\u0011\u0011Ɉ������HF\f�DDDDD2b�&\"\"\"\"�\u0011\u00037\u0011\u0011\u0011\u0011��\u0018������d��MDDDD$#\u0006n\"\"\"\"\"\u00191p\u0013\u0011\u0011\u0011\u0011Ɉ������HF\f�DDDDD2b�&\"\"\"\"�\u0011\u00037\u0011\u0011\u0011\u0011��\u0018������d��MDDDD$#\u0006n\"\"\"\"\"\u0019�>\u0001h\u0019=\u0012];NE�s�5�!��q*ڷz�kC���7RZҡC\u0007�}[3�DDD��1p{���J�\\�\u0012�N�\u0016B����`ڴiP�Tزe+���k�;l\u0003@�\u0004�\u001f�4\u0014��\n]\u0012��u�0t�8\u001b���$���t���j{RR�҇\u001a�\u0006ee�+�\u0010\u0011\u0011Q����e��������ɓ\b\b\b�\u0013O��J���͛�a�g�6\u0000t�%M�\u0006���1�O�d�t��ԁ���\u0017m��m���\u0007\u000b��ϟwϠ���ȫ1p{���*����8~�8��������o���:'I\u0017��3�R�W^y\u0005���F�CBB0�|�W���w�\u001e\u001e\u0011\u0011\u0011y!�R⥪���r�JO\u000f\u0003\u0000\u0010\u001e�@�\u0018�l����:����;＃��R\\�|\u0019-[�Dp��Ò�ϟǉ\u0013'}����h?����`[�V#;;[v���\u0013˖\u0005˂���l���\u00035\u001f�N\u0018;v��{�\u001f��,��j�\u0010E\u0011E5x���L\u001e\u0018�W\u001e𩧞�\u0005ۢ(>�wI��]�a��\u0019z�vNN���\u0007\u0000xyy���ȎmݺU��7s�\f��u�رR�-�\"���Kc\b\t\t�����K\u0001�!�3�\u0000\u0010\u001f\u000bj��LuUyzz!00P\u001as�7\u0018�����\u001d\u0000�4�-xzz���DDdZ��&�\u0001\u000b\u000b\u000bh�Z�����r�O\u0014W��۷\u001f���R�8y�$L�>��~��͡V��pa\u0010��\u0012\u0001\u0000mۺ`��E�\";��3���\u0007i�x6�X?���R�\r\u0000�o�cժ�e�222�h�b)�\u0006���\u0018|��Ҿ�s�\n�r�*|����\u0012l���bРA�~EyŇ\u000e\u001dƆ\r\u001b�m\u0000\u00188p�,���oC��wG\u001e\u0004�\u0000P����\u0013���\u0002��cƌ��\u0013\u001f\u000b����~�~�Ю];\u0000@@@�\u0014����a߾}z�(�����g�u���]�W��/�\u0018{ٕ���(m���ʂm\u0000HLL�֭[������T�oC����a�M\r���\"^_]��W\u0017����`62�\bݧi�|����A��>M[/�������x��\u000e\u001c8 m\u000b����]����\r\u0006����di\u0014'N���\u001a׿�vNڶ��0Z�#>�\u0016�\\����Uѵk7�]�V��q���r�k�Z|��W�ꩧ����$��ox��޽Ll�T�\u0017okk\u000bGG'Y�={� ##C�\u000f\b\b@��OJK֋���K�\u0019�?$����J�2�V2x�`i;**\n�U{��TnO׮]\r�9s�\ff͚�Y�f\u0019|>���\u001a\u0016��P���\u0003�\u001c\\��2\u0019\u000bi���W���[:*���5??\u000f�(J��*�\nYYY\u0006�FF^,����B����ݻ�)�W(\u0014��d�;w���r����,������V/7�ر\b�9s�ܾnݺe�^-[���+�Pp�|1\u001e\u001f\u001f\u001f�8\u0011!;��{K�~�:\b�\u0000;;;��?��s{��EFF���32ґ��\u000eGG�lsٴ���$�~��^\u001fՕ���\u000e\u001d:\u0000\u0000ڷo�͛7���È�����\u0013\u0011Q��\u0019njT\".�R�={��[_(1k�\u0000';��\u0019u�v��\u0004\\�\u0000I\u0014˟\u0001�ljGAAA�\u0006fDZ�� ��\u001a��)\"�g�\ry�Gd��r�������M�\u0002��Z�;WR�eʔ������{DF^����JJ�����\u001b��6i�Z�={\u0016����ᇒ��VVVh�Ī��ADDUǀ�\u001a\u001d{\u001b`�$\u0001?�Qbp\u000f\u0001֖��Q�EX��3ݍY�Z�^^^���n��R�D@�\\i_�V#.M�\u000e\u001de\u000f;�[�\u000e\u001f}�EZ\tT�T��w\u0003*\u001c���%U]�\r{V�  �\"\"\"\f/��P\bhݺM�}�eoo�y��a޼�x�w�-�x��qپ�U�*ߋ���\u000e\u0003nj�ܝ�O�\u0011\u0010\u0016������1�n����d\u000f�Μ9\u0003mۺ���\u0002�weu�O����1\u001d�\u0010\u00000uc!��\u0016��k\u001f�`���\u0007*�������� [����JZ!�����c��@\u0014\u0015�z�t�E�n%+4~��\u000e��e׭]�\u000e�6m� \bP*�\b\f\fļy��\u001dSDD\u0004F�\u001c)�k4\u001a��w�\u0015�Yq���#?�h\u000b\u0016/^\u0004{{{\u0000�U4�|�I�mO�:��?�V������1��\u001a��>\n)-䛓\"���,p�泺���\r�x�n;7_�n�~\u0011ߜ,\th��n����\u0005l��O�\u0002�ҕ;��˟�7�_U�>���\u000b�\u0014+,�z�Ϯ]��f�\u001a$%%\u0019>\u001e�u\u0015�.]Dtt��>\u0006\r\u001a\u0004kk�*�7>>\u001e���F�X[�`�����򄽽=���QP�ENN6����ȑ#���U��\u001a\u0012\u00100\u0017���\u0000\u0000?�'0q��\u001a�IDD\r\u0007\u0003n\"�7\u001d:t����T����C�\u000e�С\u0003F�\u001a���X,]�\f\u001a����^{�`\u001f�h4�r\u0003[�R�wޙ�.]:C\u0010�ϖ[XX���\u001a-Z����\u0013�z�*V�X\u0001�V[���֮];Y�*�=�޽S�����aa�\u0012\"�\u0017�=7\u0002\u000b\u0017.�T����͛7�ٹ���ec�\u0014\u001f|�\u0001�u�\u0017l\u001bҡC\u0007lڴ\t���վ���.m߽{��6\u0011�C�3�DT�z�ꅗ_~Iv��_������￯�iӦ�ر#�{�9888\u0000\u0000ll��b�r���[\u0010��r��~�:���*\u001cÝ;�A�B!`��5h֬�tL\u0014E������/� 99\u0019..mѹsg���\u001b66�4\u0016[[[�_�\u001e\u000b\u0016,�V���͛q��\u00194kf�_~9S�뉈�ac�MDu�W^���Z-V�\\����S:v��]���#�d\\�X���!C�`���\u0000�ӧO���?7�n���x��ЪU+�{�޽{8|�p���DDT�\u0018p\u0013U���-\u0000ݬ��s+�\\�\u0002���6� ���\u001e�'Oƀ\u0001\u0003�x�\u0012�\u0001���\u0013V�Xnp����\u0002...pqqA׮]\u0011\u0018\u0018�\u0017\u0000��4���\r\u0000���\u000b�\u0016\u0005I���3r�(�\u001d;F� \b�������1`�\u0000̟\u001f���\u0004�v��\u0016X�d\u0011ڵs3؇��=&L��!C� 0���ϓ�)(�@\u0014E)@�ܹ3Μ1��|�D\u0004N��0ڦ�����파�J\u0007�YYY8r�;i�=))���vpp����+�\u0014S*��3g\u000e|||��\t�\u0000�J�\t\u0013&`Ĉ\u0011���Sn5\u0017\"\"�\u001fL)!�&A\u0010�l�RY����\u000bQ�\u0007��۷������W(\u0004�\\�B/ؾ�>222de朝��z�j��i۶�^���jQXX��K/�$\u000b��Z-\u0012\u0013�\u0010\u001f\u001f/��R�����\u0006�QV�X�\u0017l���\"77Wv���\u0019˗\u0007\u001b\u001ckvv��ݷo_�\u001b7\u000e����35g��v�!����_a޼y�7o\u001e�����\u001e\u001a�.]&\u000b��j5��n\"55U�~���ǒ%�k��DDT3��&�&A\u0010�����݋��\b���B�T�k�nx������\u0005�������ƕ+W��\u0007\u000f\u001e,]\u000f\u0000�N����ۥ�W\u0010�0q��\u00180`\u0000\u0000�,hӦ͐�}�踒���s�N\\��^5�aÆI۷n�cɒ%�ԑ\u0001\u0003\u0006��7�\u0000\u0000�����~8~��t~���ЪUIi���h�^�\u000699�\u0000�Ʀ)��{\u0017���\u0000tA��!C��?������b\t����?�aÆ���/ ��T���>���_��W�\\\u0001�nݦ�FDDDU�\u0019njT\".��}\u0010\u001b�\u001e#���\u0002և��☈�'����?�,�~�΍\u001b��}'''��X��������:�ѱ\u0005,,�afffpYq��\t�����O>�����L��۵sC@@\u0000DQDjj*._����0��t�Y`+++�޽���\u0015stt,��(\u0016\"�͛�`eG�Ν+I�(��p��EYP7e��r�pppĒ%K�t�R,]�\u0014M���\u0013�~�$pW�T\u0006�+/kР�ҶF�)��aM�;w^V�eذa���\n��9s�,��t������aeem�1�F���n={�2�F�ɗ}P��jR��\u0010\u0011��0�F��\u0019��\u001d\u0001a�J)�\u000e�_�\u0006�\u00000{�l�i#O\u001d����ҥ��f���.Tڎ��%\u000b^'M���v�ʕ+d�j2�maa\u0001\u001f�N�����`�fkk�\u0001\u0003�����3J�-�-y�����q�٩�j�J�o�\u001e���P�T��\u0019aa�T���\u0000���\u000b\u0006�lc�\u0014�V�/��r�ܹ\n_ku�b!6l�(�\u000b�����\u000fJ\u0011��÷h�\u0002\u001b6l����t,99\u0019�.]�k�h�\"lڴ\t۶}��^z�J�rqq��no�=UZP�4\u000f��h۶�=x���*݃��L�9��`D�\u0016���\"�c�∪YI�\u0005;E��\u0016��pܝ\u0001�6�����/HXk�J%�\u0015�j5\u0012\u0012\u0012���W�$55\u0015'NDȎݼy\u0013�۷\u0007\u0000��=�^�z�ƍ\u001b��˃���^\u001f5u��Y��ji�3g�֭x���\u0015(�J888�ǧ��C=_��غ�ct��M�p��SO���\u000fqqq��ʂ��\u001b���d3�\u001f~������t\u001c;v\f�\u0006\r\u0002�\u000blG�\u001e�g�}\u0016III�u�\u0016,,,���\b��[���h4���ʗ#��������_ѧO\u001fil�ǿ��c� &&\u0006ii�prrD�6mмys���j5V�Z�ק��#����\u001b6l(���J���۷\u000f�z�>\u001c)�J�]�\u0016W�����d\u0014\u0014h���.�\u000f�\u001eh=p�`��\r����1�\u0006�\u0010\u0011���\u0002��4��\u0006�{�$ ����\u001c�� �ClS7\u0016bxo\u0001.N��Q��\\\u000b�:^irϞ�x�\u0015݌����\u0014@�v��},Z�H��ƍ��b�\n�\u0001B�R\tOOOY\u001b�V��~�I\nNk���M�0k�,)U���\u0005��.z�DQħ�nGdd��F��\u0005\u000b\u0016bٲ�R�mnnn�u�����\u0010�Ep\u0000`ǎ\u001dHHH�k��&\u0005�VVVR�;C\u0012\u0013��hQP�\u000fY���͛q��]\f\u001f��t����h����ױ|�r�\u0005t\u0000�8�%55\u0015\u0007\u000f\u001e�ȑ#!\b\u0002\u0004A�f��R��X�t)rs��a\u0006\"\"2�)%� ��QHi!ߜ�-�^}:bbb\f��x��5̞폴��� �9��\n\n\n�4�K�.a�ԩ�z����/�.��}�6���q��O\u0006�HH��iӦ��ٳ\u0006�-�\"n�N���?\u000e\u001c8P�X���\u0011\u0018�_ܹs�`?��;y�\u0014�ΝSn�m���س�K,_�\u001c���F�\u0015\u0014\u0014��o�cѢE\u0006�m@Wڰ���(�8r�*\u0007�\u0007\u000e\u001c@`` ���\f�V�Z��\u0017/b�Է\u0011\u0017\u0017W������\u0014(IN,�������~\u0004\u0003�\u0015����V�\u0017�4�\u000b\u0000@�#��@����+\u0010����/�\u0014�#E8\u001d�\u000b�\u001fi��H?�ޢ6��\"��H�\u0004��\u0000�6\n\u0004�\u0013��Q��\u001d\u001eT(�|צ/�,I��0a�\u0014�6m�\f\u001e\u001e�hڴ)n݊GRR����5Qcef&�ϯ(�ؾ��*��\u0013\u0011Q�ǀ���~��g���\u001e\u0000-,�����qKII��\u001b7q�N\u0006���\u0011\u001a\u001a�r~DD\u000f)\u0006�DU�u���\u001e\u0002=\u0004���a�����0���\u000e4�2\u000fDDDDD\u000f\u0019\u0006�DDDDD&Ā�����Ȅ\u0018p\u0013\u0011\u0011\u0011\u0011�\u0010\u0003n\"\"\"\"\"\u0013b�MDDDDdB\f������L�\u00017\u0011\u0011\u0011\u0011�\t1�&\"\"\"\"2!\u0006�DDDDD&Ā�����Ȅ\u0018p\u0013\u0011\u0011\u0011\u0011�\u0010\u0003n\"\"\"\"\"\u0013b�MDDDDdB\f������L�\u00017\u0011\u0011\u0011\u0011�\t1�&\"\"\"\"2!\u0006�DDDDD&Ā�����Ȅ��=\u0000�g��\u0004���3�DD��1���\u0016XXX��ҲF}X[[C�����\n�����ܢ\u0016�2N\u0010�`cӴV�j��\n��6��Wyjk�DDDU�\u0019n�j\u001a0` �~�)�j�\nVVV\u0000\u0000Q\u0014q��=\u001c>|\u0018��G\u0001������\u0005���\u0011x�g`cc\u0003A�}��j�HH���{�!**�൞���;w.\u0000��ٳ��\u001d\u0018;v,�w�֭[A\u0010\u0004deeaʔ)X�z\r�7�\u0005\u0000\u001c8p\u0000?��c�cR*�شi\u0013��t�\u0014\u0005\u0007\u0007#..N����\u0003���*��ݥ\u000f\b�(\"//\u000f�N����\u0007�V�\u001a�?00\u0010nnn\u0010E\u0011�;\u000f���\u00185j\u0014���`cc\r\u0000ؼy3~���r�Xl�ƍhҤ\tDQ��ٳ���O[[[���\u001bpww�J����5\u001a\r�^��\u001d;v 55��{\u0011\u0011\u0011�\u0004\u0003n�*R*��3g\u000e|||��\t�\u0000�J�\t\u0013&`Ĉ\u0011���\u0003�F}�\u0016-Z 88\u0018���\u0006�o��\r�����ӧ�e�\u0016�666Mac��\r���¢EA���48ތ�\f�n�\n\u00000l�0�\u0001w߾�`k�\u000b�EQDRR���k���СC\f�nkkk\f\u001d:\u0014\u0003\u0006\f�A�};^�����4�޽{��W�-\u0005�UU:�����\u000b����\u0011\u0010\u0010`�[\u0003\u000b\u000b\u000bt��\u0019�ׯ�'�|��~:Q�1\u0010\u0011\u0011U\u0006SJ��h��e�`[�V#.�&RSSe�3����d�b�뭭m�z�j�`;;;\u001b\u001a�Fv�o߾�8q���m�V/��j�(,,\u0004\u0000���Hǝ����U\f\u001c8@ڎ���}X\u0018?^?��h4��Ζ\u001d���@p�\n�CƏM\u0016lk�Z�����\u0014�4OO/\u0004\u0006\u0006�f�322\u0010\u001b\u001b\u000b�Z-k;i�[�����M�����\u0019nj�bS��ɺ�˷�\u0002ve���\"ܽ\u000f��\u0001��\u0015u2��m]���\"퇇�c׮]�Z(0g�\u001ct��\u0015\u0000���\n[[[deeI-�Ν#�u=r�;���\r�Z-\u0000�ٹ\u0015�-[*��\f\u001a4\b��\u0003�����-99\u0019;w�ĕ+B\u0014\u000b��W��\u0005�Z-�7x�3���o��W*�pss��\u000f\u001d:,{�C��\u0004�99�\b\n\n�ƤT*1n܋\u0018>�Yi֬w\u0010\u001c\u001clt̢(����8y�$�ܹc�mUL�8A�V��\b\nZ���\u0004�X��m�j�J)�\u001f=�\u0005�\\����ODDT\u001ag����}\\��\u000b���B\\�^2�\u0019\u0019[��Ӵx>Hw���Bt��Edl-L�V���]�.(((\u0013l\u0003@\u0011֭[���h���\"55\u0015*�J:kg���W�l�#G�o�^)�\u001b�Kx\u0000\u0000 \u0000IDAT\u0006���$�����MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>��MD�j��\u0000\u0000 \u0000IDATDDD�C\f�DDDDD>��MDDDD�C\f�DDDDD>t�\u0003�h�������l�,�\u0019n\"\"\"\"\"\u001fb�&\"\"\"\"�!\u0006n\"\"\"\"\"\u001fb�&\"\"\"\"�!w\u00037/v$\"\"\"��:�2qW�ps�\u0012\"\"\"\"�s\"k�\u0012��=�s�\u0013\u0011\u0011\u0011�_��2���|9�-��&\"\"\"\":\u0017���j+p3\u001c\u0013\u0011\u0011\u0011\u0011uN�,��\u0019no\u0004u�}\"\"\"\"��9�K�\u0003wg:\u0015�\u001e��%\"\"\"\":\u0017��_]ͺv���*%�\u001d \u0011\u0011\u0011\u0011�����U�\u0002�*Pg0'\"\"\"\"o��1�$oz;p;���PMDDDD]�Y^�jf��ѡ/�2g������W|�5]���f�;;[��7��MDDDD��E\u0016�t��lI�����j�pMDDDDg���\u000eܞt����cDDDDD���\\�\\�ew����MDDDD�vNdLO\u0003�;w��\u0016��!\"\"\"\"�\fws�O��J�v40W��f\u0018������[\u001ceNodZ���ōo�\t�\\&������͓����nw\u0002wg�G\\9�\"\"\"\"\"w�rgIg\u0017Mz%|{��I[����;�\u0003$\"\"\"\"_�^�\u000f\u000e�}v]���ݙz\u0016W�9z�\f�DDDD�){�\u0015��7f�����\f�'E�ξM\u0010\u0011\u0011\u0011\u0011y�7r�G�ߞ�ڽ33ێ�q��������Q�t�I\u001d��N{\u0013[��������[�\u00106ژ�8q\"���ODDDDq����V��3�\u001f��a;��y2{\u0007\\����]\u0005�����DDDD�Y�\\(i빽���o����\u0012O\u0006b���+D\u0019������S�̜\u001e��ή��j=���\u0019{��\"�J�����]�r\u0012�\u0019\u0013�eW�~�w�^��Z͊�~{�ܶ�qp�������e+K:ʠ����t���\u0002���V;g\u001f\u0004\u00037\u0011\u0011\u0011\u0011��Y�tgb�ka��\u0013'N$�𵉈���",
        "tags": []
    },
    {
        "uri": "/posts/2022/06/vite-origin-1/",
        "title": "vite -- 从0阅读vite之1",
        "content": "\n从0阅读vite\n\ncommit1\n\nvite项目的第一个提交，只有6个文件有代码，真实代码不会超过1000行，所以说真的是又个好的想法，尽管去实现，即使一开始很糟\n\n从server.js入手\n\n第一步就是使用http创建了一个nodejs server，同时解析请求的url\n\n__hmrProxy结尾，即走sendJS\n以.vue结尾，则走vue方法\n否则走serve方法\n\n同时监听在3000端口\n\nconst server = http.createServer((req, res) => {\n  const pathname = url.parse(req.url).pathname\n  if (pathname === '/__hmrProxy') {\n    sendJS(res, hmrProxy)\n  } else if (pathname.endsWith('.vue')) {\n    vue(req, res)\n  } else {\n    serve(req, res)\n  }\n})\n// .....\n\nserver.listen(3000, () => {\n  console.log('Running at http://localhost:3000')\n})\n\n通过ws库创建了一个websocket实例，并且在链接的时候记录下链接的socket\n\nconst wss = new ws.Server({ server })\nconst sockets = new Set()\nwss.on('connection', (socket) => {\n  sockets.add(socket)\n  socket.send(JSON.stringify({ type: 'connected'}))\n  socket.on('close', () => {\n    sockets.delete(socket)\n  })\n})\n\ncreateFileWatcher执行，遍历sockets, 可以推测出就是发送消息\n\ncreateFileWatcher((payload) =>\n  sockets.forEach((s) => s.send(JSON.stringify(payload)))\n)\n\nsendJS\n\n不过时对 http的response 进行了封装，写入了\n\nfunction send(res, source, mime) {\n  res.setHeader('Content-Type', mime)\n  res.end(source)\n}\n\nfunction sendJS(res, source) {\n  send(res, source, 'application/javascript')\n}\n\nvue\n\n走vueMiddleware.js\n\n通过解析请求路径中的文件名，再调用parseSFC读取文件名，最终返回descriptor\n\nconst parsed = url.parse(req.url, true)\nconst query = parsed.query\nconst filename = path.join(process.cwd(), parsed.pathname.slice(1))\nconst [descriptor] = parseSFC(filename)\n\ndescriptor包括script、template、style，这不是正好是vue模版文件的三个属性吗，可以推断出是使用@vue/compiler-sfc'去解析的\n\nif (descriptor.script) {\n  code += descriptor.script.content.replace(\n    export default,\n    'const script ='\n  )\n  code += \\nexport default script\n}\nif (descriptor.template) {\n  code += `\\nimport { render } from ${JSON.stringify(\n    parsed.pathname + ?type=template${query.t ? &t=${query.t} : }\n  )}`\n  code += \\nscript.render = render\n}\nif (descriptor.style) {\n  // TODO\n}\ncode += \\nscript.__hmrId = ${JSON.stringify(parsed.pathname)}\nreturn sendJS(res, code)\n\n其中对于script、template 都进行了赋值组装代码\n\nfileWatcher\n\n通过使用第三方库chokidar监听文件的变化，如果文件发生变化，即重新走parseSFC，最后会比对， script的内容或者template的内容发生变化时，会调用notify通知\n\nconst fileWatcher = chokidar.watch(process.cwd(), {\n    ignored: [/node_modules/]\n  })\n\n  fileWatcher.on('change', (file) => {\n    if (file.endsWith('.vue')) {\n      // check which part of the file changed\n      const [descriptor, prevDescriptor] = parseSFC(file)\n      const resourcePath = '/' + path.relative(process.cwd(), file)\n\n      if (!prevDescriptor) {\n        // the file has never been accessed yet\n        return\n      }\n\n      if (\n        (descriptor.script && descriptor.script.content) !==\n        (prevDescriptor.script && prevDescriptor.script.content)\n      ) {\n        console.log([hmr]  for ${resourcePath} changed. Triggering component reload.)\n        notify({\n          type: 'reload',\n          path: resourcePath\n        })\n        return\n      }\n\n      if (\n        (descriptor.template && descriptor.template.content) !==\n        (prevDescriptor.template && prevDescriptor.template.content)\n      ) {\n        console.log([hmr]  for ${resourcePath} changed. Triggering component re-render.)\n        notify({\n          type: 'rerender',\n          path: resourcePath\n        })\n        return\n      }\n\n      // TODO styles\n    } else {\n      console.log([hmr] script file ${resourcePath} changed. Triggering full page reload.)\n      notify({\n        type: 'full-reload'\n      })\n    }\n  })\n",
        "tags": [
            "vite",
            "plugin"
        ]
    },
    {
        "uri": "/posts/2022/05/vite-server/",
        "title": "vite--server对应源码",
        "content": "\nvite server\n\n> 3.0.0\n\n源码位置\n\npackages/vite/src/node/server/index.ts\n\ncreateServer\n\n步骤\n\n解析配置文件\n\n      const config = await resolveConfig(inlineConfig, 'serve', 'development')\n\n创建中间件的容器，使用的第三方库connect, 默认可以兼容express、koa等第三方node服务库， 后续会把相应的中间件加入到实例中\n\n        const middlewares = connect() as Connect.Server\n\n创建httpServer实例，使用的是node原生http库\n\n       const httpServer = middlewareMode\n       ? null\n       : await resolveHttpServer(serverConfig, middlewares, httpsOptions)\n\n创建出一个websocket实例，使用第三方库ws\n\n        const ws = createWebSocketServer(httpServer, config, httpsOptions)\n\n创建出一个文件夹监听实例，使用第三方库chokidar,  监听目标目录下文件的变动， 也就是对应的热更新操作\n\n        const watcher = chokidar.watch(path.resolve(root), {\n       ignored: [\n         '/node_modules/',\n         '/.git/',\n         ...(Array.isArray(ignored) ? ignored : [ignored])\n       ],\n       ignoreInitial: true,\n       ignorePermissionErrors: true,\n       disableGlobbing: true,\n       ...watchOptions\n     }) as FSWatcher\n\n创建模块依赖moduleGraph,记录文件模块依赖\n\n   构建插件容器\n\n      const moduleGraph: ModuleGraph = new ModuleGraph((url, ssr) =>\n   \tcontainer.resolveId(url, undefined, { ssr })\n   )\n   const container = await createPluginContainer(config, moduleGraph, watcher)\n\n构建一个server对象，包括当前上下文的参数等等\n\n   交给后续上下文使用\n\n       const server: ViteDevServer = {\n    \t// ....\n    }\n\n监听文件的变化、新增、删除等操作,  会进行相应的热更新操作\n\n      watcher.on('change', async (file) => {\n       file = normalizePath(file)\n       if (file.endsWith('/package.json')) {\n         return invalidatePackageData(packageCache, file)\n       }\n       // invalidate module graph cache on file change\n       // 模块依赖更新\n       moduleGraph.onFileChange(file)\n       if (serverConfig.hmr !== false) {\n         try {\n           // 热更新操作\n           await handleHMRUpdate(file, server)\n         } catch (err) {\n           ws.send({\n             type: 'error',\n             err: prepareError(err)\n           })\n         }\n       }\n     })\n\n     watcher.on('add', (file) => {\n       handleFileAddUnlink(normalizePath(file), server)\n     })\n     watcher.on('unlink', (file) => {\n       handleFileAddUnlink(normalizePath(file), server)\n     })\n\n遍历所有的插件，同步拿到配置服务的结果\n\n        const postHooks: ((() => void) | void)[] = []\n     for (const plugin of config.plugins) {\n       if (plugin.configureServer) {\n         postHooks.push(await plugin.configureServer(server))\n       }\n     }\n\n在服务中间件中添加一些列的中间件，包括请求时间、跨域处理、proxy代理、根目录读取html、静态资源服务、错误处理等\n\n启动服务\n\n返回server给外部使用\n",
        "tags": [
            "vite",
            "websockt"
        ]
    },
    {
        "uri": "/posts/2022/05/vite-websocket/",
        "title": "Vite Websocket源码",
        "content": "\nVite -- websocket相关源码\n\n> 2.9.8\n\npackages/vite/src/node/server/ws.ts\n\ncreateWebSocketServer\n\n源码通过在函数内实例化ws，返回一个对象函数，充分利用js闭包的属性\n\nfunction createWebSocketServer() {\n\t// .... source code\n\treturn {\n\t\ton: () => {},\n\t\toff: () => {},\n\t\tsend: () => {},\n\t\tclose: () => {},\n\t}\n}\n\nWebSocketServerRaw就是开源社区的ws库，也是常用的websocket封装库\n\nwss = new WebSocketServerRaw(websocketServerOptions)\n\nwss.on('connection', (socket) => {\n    socket.on('message', (raw) => {\n          if (!customListeners.size) return\n          let parsed: any\n          try {\n            parsed = JSON.parse(String(raw))\n          } catch {}\n          if (!parsed || parsed.type !== 'custom' || !parsed.event) return\n          const listeners = customListeners.get(parsed.event)\n          if (!listeners?.size) return\n          const client = getSocketClient(socket)\n          listeners.forEach((listener) => listener(parsed.data, client))\n    })\n    socket.send(JSON.stringify({ type: 'connected' }))\n})\n\n连接成功后，监听socket的message事件，并且发送了一个connected标识符\n\n监听事件内部，从customListeners获取到对应的事件数组，事件是分类存放的，最终存放在一个map中\n\n  const customListeners = new Map>>()\n  const clientsMap = new WeakMap()\n\nreturn\n\non\n\n暴露到外部的方法，用作添加ws的监听函数\n\n原生事件：直接添加监听\n\n非原生事件： map中不存在对应事件时，添加一个对应的对象，并且添加到Set中去\n\nif (wsServerEvents.includes(event)) wss.on(event, fn)\nelse {\n    if (!customListeners.has(event)) {\n      customListeners.set(event, new Set())\n    }\n    customListeners.get(event)!.add(fn)\n}\n\noff\n\n原生事件： 直接解除监听\n非原生事件： 删除对应Set中的事件\n\nif (wsServerEvents.includes(event)) {\n        wss.off(event, fn)\n} else {\n\tcustomListeners.get(event)?.delete(fn)\n}\n\nsend\n\n对发送的数据进行格式化处理，数据包装成一个固定格式\n\n拿到所有的客户端实例，遍历发送\n\nlet payload: HMRPayload\nif (typeof args[0] === 'string') {\n    payload = {\n      type: 'custom',\n      event: args[0],\n      data: args[1]\n    }\n} else {\n    payload = args[0]\n}\n\nif (payload.type === 'error' && !wss.clients.size) {\n    bufferedError = payload\n    return\n}\n\nconst stringified = JSON.stringify(payload)\nwss.clients.forEach((client) => {\n    // readyState 1 means the connection is open\n    if (client.readyState === 1) {\n      client.send(stringified)\n    }\n})\n\nclose\n\n关闭的时间遍历循环，执行terminate方法\n\nreturn new Promise((resolve, reject) => {\n    wss.clients.forEach((client) => {\n      client.terminate()\n    })\n    wss.close((err) => {\n        if (err) {\n        \treject(err)\n        } else {\n        if (httpsServer) {\n          \thttpsServer.close((err) => {\n                if (err) {\n                  reject(err)\n                } else {\n                  resolve()\n                }\n             })\n        } else {\n          resolve()\n        }\n       }\n    })\n})\n",
        "tags": [
            "vite",
            "websocket"
        ]
    },
    {
        "uri": "/posts/2022/05/vite.issue/",
        "title": "vite使用中相关问题整理",
        "content": "\n问题清单\n\nvite中使用optional chain ?. 失效问题\n\n引入rollup-plugin-esbuild\n\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport esbuild from 'rollup-plugin-esbuild'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    vue(),\n\n    {\n      ...esbuild({\n        target: 'chrome70',\n        // 如有需要可以在这里加 js ts 之类的其他后缀\n        include: /\\.vue$/,\n        loaders: {\n          '.vue': 'js',\n        },\n      }),\n      enforce: 'post',\n    }\n  ],\n})\n",
        "tags": [
            "vite"
        ]
    },
    {
        "uri": "/posts/2022/06/websocket-usage/",
        "title": "vite 中websocket使用",
        "content": "\nvite 中有关 websocket 的使用\n\n封装\n\n项目是基于第三方npm包 ws, 这个包是为服务端使用websocket而设计的，并不适用浏览器中，项目地址 https://github.com/websockets/ws\n\n项目中文件路径\n\n>   \"version\": \"3.0.0-alpha.9\"\n\npackages/vite/src/node/server/ws.ts\n\n源码\n\n源码中有三个比较重要的变量\n\n  let wss: WebSocketServerRaw\n\n  const customListeners = new Map>>()\n  const clientsMap = new WeakMap()\n\nwss：websocket的实例对象\n\ncustomListeners: 一个map类型，保存了类型所对对应的变量数据结构，其中WebSocketCustomListener也是一个对象\n\nexport type WebSocketCustomListener = (\n  data: T,\n  client: WebSocketClient\n) => void\n\nclientsMap:  客户类型所对于的weakMap类型，保存的是连接实例对应的对象，\n\n连接部分和消息处理部分的源码\n\nwss.on('connection', (socket) => {\n    socket.on('message', (raw) => {\n      if (!customListeners.size) return\n      let parsed: any\n      try {\n        parsed = JSON.parse(String(raw))\n      } catch {}\n      if (!parsed || parsed.type !== 'custom' || !parsed.event) return\n      const listeners = customListeners.get(parsed.event)\n      if (!listeners?.size) return\n      const client = getSocketClient(socket)\n      listeners.forEach((listener) => listener(parsed.data, client))\n    })\n    socket.send(JSON.stringify({ type: 'connected' }))\n    if (bufferedError) {\n      socket.send(JSON.stringify(bufferedError))\n      bufferedError = null\n    }\n  })\n\n连接成功后会发送一个connected事件\n\n      socket.send(JSON.stringify({ type: 'connected' }))\n\n消息处理部分会先把字符串反序列化，上下文中可以看出对象有一个type属性和data属性\n\n从customListeners中取出对应的type所对存储的事件集合\n\ngetSocketClient对于即将发送的数据进行包装成特定格式，并且存入到clientsMap中\n\nfunction getSocketClient(socket: WebSocketRaw) {\n    if (!clientsMap.has(socket)) {\n      clientsMap.set(socket, {\n        send: (...args) => {\n          let payload: HMRPayload\n          if (typeof args[0] === 'string') {\n            payload = {\n              type: 'custom',\n              event: args[0],\n              data: args[1]\n            }\n          } else {\n            payload = args[0]\n          }\n          socket.send(JSON.stringify(payload))\n        },\n        socket\n      })\n    }\n    return clientsMap.get(socket)!\n  }\n\n\u0003\t5. 对事件集合进行遍历执行\n\nlisteners.forEach((listener) => listener(parsed.data, client))\n\n错误处理部分的源码\n\n  wss.on('error', (e: Error & { code: string }) => {\n    if (e.code === 'EADDRINUSE') {\n      config.logger.error(\n        colors.red(WebSocket server error: Port is already in use),\n        { error: e }\n      )\n    } else {\n      config.logger.error(\n        colors.red(WebSocket server error:\\n${e.stack || e.message}),\n        { error: e }\n      )\n    }\n  })\n\n函数返回\n\n函数最终返回一个对象，包括事件的注册、解除、发送对于的数据、连接关闭、获取所有的连接等等\n\n注册\n\n其实就是向customListeners中存入对应事件的Set\n\n{\n  on: ((event: string, fn: () => void) => {\n      if (wsServerEvents.includes(event)) wss.on(event, fn)\n      else {\n        if (!customListeners.has(event)) {\n          customListeners.set(event, new Set())\n        }\n        customListeners.get(event)!.add(fn)\n      }\n    })\n}\n\n解除\n\n找到对应事件并且删除\n\n    off: ((event: string, fn: () => void) => {\n      if (wsServerEvents.includes(event)) {\n        wss.off(event, fn)\n      } else {\n        customListeners.get(event)?.delete(fn)\n      }\n    }) as WebSocketServer['off'],\n\n获取所有的客户端连接实例\n\n把websocket实例上所有的客户端连接进行去重，并且查看是否储存在clientsMap中\n\n get clients() {\n      return new Set(Array.from(wss.clients).map(getSocketClient))\n },\n\n发送\n\n对于传入的参数进行判断，以特点的格式进行发送，拿客户端连接实例的数组并遍历，最终把数据广播发送出去\n\n  send(...args: any[]) {\n      let payload: HMRPayload\n      if (typeof args[0] === 'string') {\n        payload = {\n          type: 'custom',\n          event: args[0],\n          data: args[1]\n        }\n      } else {\n        payload = args[0]\n      }\n\n      if (payload.type === 'error' && !wss.clients.size) {\n        bufferedError = payload\n        return\n      }\n\n      const stringified = JSON.stringify(payload)\n      wss.clients.forEach((client) => {\n        // readyState 1 means the connection is open\n        if (client.readyState === 1) {\n          client.send(stringified)\n        }\n      })\n    },\n\n关闭\n\n遍历客户端数组并关闭，并返回一个promise对象\n\n  close() {\n      return new Promise((resolve, reject) => {\n        wss.clients.forEach((client) => {\n          client.terminate()\n        })\n        wss.close((err) => {\n          if (err) {\n            reject(err)\n          } else {\n            if (httpsServer) {\n              httpsServer.close((err) => {\n                if (err) {\n                  reject(err)\n                } else {\n                  resolve()\n                }\n              })\n            } else {\n              resolve()\n            }\n          }\n        })\n      })\n    }\n",
        "tags": [
            "websocket"
        ]
    },
    {
        "uri": "/posts/2022/06/built-in-directive/",
        "title": "vue -- 内置指令源码分析",
        "content": "\nvue内置指令\n\n>   \"version\": \"3.2.37\"\n\nvue因为在核心中内置了一些指令，开箱即用就非常nice\n\nv-model\n\nvue中最具特色的指令就是v-mode了，可以把input的值进行绑定，结合双向绑定，可以最少代码就能把输入的值显示到页面上\n\nMessage is: {{ message }}\n\n看一下vue3下面的具体实现\n\n> packages/runtime-dom/src/directives/vModel.ts\n\nvModelDynamic\n\n在不同的生命周期下调用不同的勾子函数，包括created,mounted,beforeUpdate,updated这四个生命周期\n\nexport const vModelDynamic: ObjectDirective = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'created')\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'mounted')\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate')\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'updated')\n  }\n}\n\nfunction callModelHook(\n  el: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n  binding: DirectiveBinding,\n  vnode: VNode,\n  prevVNode: VNode | null,\n  hook: keyof ObjectDirective\n) {\n  const modelToUse = resolveDynamicModel(\n    el.tagName,\n    vnode.props && vnode.props.type\n  )\n  // 这里modelToUse就可以看出是一个包含不同生命周期函数的对象，隐藏了最终的实现，其实就是一种adapter模式\n  const fn = modelToUse[hook] as DirectiveHook\n  fn && fn(el, binding, vnode, prevVNode)\n}\n\nresolveDynamicModel\n\n这里一看，其实是根据不同的标签名走不同的分支了，正常需要去用v-model的元素就这么几类了\n\nfunction resolveDynamicModel(tagName: string, type: string | undefined) {\n  switch (tagName) {\n    case 'SELECT':\n      return vModelSelect\n    case 'TEXTAREA':\n      return vModelText\n    default:\n      switch (type) {\n        case 'checkbox':\n          return vModelCheckbox\n        case 'radio':\n          return vModelRadio\n        default:\n          return vModelText\n      }\n  }\n}\n\ngetModelAssigner\n\n这是一个非常重要的函数了，直接决定了绑定元素对外响应的所绑定的函数\n\nconst getModelAssigner = (vnode: VNode): AssignerFn => {\n  const fn =\n    vnode.props!['onUpdate:modelValue'] ||\n    (COMPAT && vnode.props!['onModelCompat:input'])\n  return isArray(fn) ? value => invokeArrayFns(fn, value) : fn\n}\n\n最终响应的是props上的update:modelValue所绑定的事件，这里就和vue2不太一样了，内部绑定的值也换成modelValue了\n\n官方文档说明\n\nhttps://v3.cn.vuejs.org/guide/migration/v-model.html#v-model\n\nvModelText 常规文本绑定\n\ncreated生命周期内绑定事件，lazy修饰符表示走不同的监听方法\n\nmounted生命周期内重置输入框初始值\n\nbeforeUpdate周期内旧值和新值不相等时，会重新赋值\n\nexport const vModelText: ModelDirective = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    // 元素是否包含number属性\n    const castToNumber =\n      number || (vnode.props && vnode.props.type === 'number')\n    // 事件绑定，lazy修饰符表示走不同的监听方法\n    addEventListener(el, lazy ? 'change' : 'input', e => {\n      if ((e.target as any).composing) return\n      let domValue: string | number = el.value\n      // trim修饰符\n      if (trim) {\n        domValue = domValue.trim()\n      }\n      // 是否是数字，是数字格式化\n      if (castToNumber) {\n        domValue = toNumber(domValue)\n      }\n      el._assign(domValue)\n    })\n\n    // 包含trim修饰符时，监听change方法同样需要trim\n    if (trim) {\n      addEventListener(el, 'change', () => {\n        el.value = el.value.trim()\n      })\n    }\n    if (!lazy) {\n      addEventListener(el, 'compositionstart', onCompositionStart)\n      addEventListener(el, 'compositionend', onCompositionEnd)\n      // Safari  = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el._assign = getModelAssigner(vnode)\n    addEventListener(el, 'change', () => {\n      // model绑定的值\n      const modelValue = (el as any)._modelValue\n      // 元素上的value值\n      const elementValue = getValue(el)\n      // checked状态\n      const checked = el.checked\n      const assign = el._assign\n\n      if (isArray(modelValue)) { // 绑定值是数组\n        const index = looseIndexOf(modelValue, elementValue)\n        const found = index !== -1\n        // 当前选中了，但是绑定值中没有，需要插入\n        if (checked && !found) {\n          // 放入并响应\n          assign(modelValue.concat(elementValue))\n        } else if (!checked && found) { // 没有选中，但是绑定值中有对应值，则需要删除\n          const filtered = [...modelValue] // 复制\n          filtered.splice(index, 1) // 删除\n          assign(filtered)\n        }\n      } else if (isSet(modelValue)) { // 绑定值是Set\n        const cloned = new Set(modelValue) // 复制\n        if (checked) {\n          cloned.add(elementValue)\n        } else {\n          cloned.delete(elementValue)\n        }\n        assign(cloned)\n      } else {\n        assign(getCheckboxValue(el, checked))\n      }\n    })\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el._assign = getModelAssigner(vnode)\n    setChecked(el, binding, vnode)\n  }\n}\n\nfunction setChecked(\n  el: HTMLInputElement,\n  { value, oldValue }: DirectiveBinding,\n  vnode: VNode\n) {\n  // store the v-model value on the element so it can be accessed by the\n  // change listener.\n  // 预先重置元素上的modelValue值\n  ;(el as any)._modelValue = value\n  if (isArray(value)) {\n    el.checked = looseIndexOf(value, vnode.props!.value) > -1\n  } else if (isSet(value)) {\n    el.checked = value.has(vnode.props!.value)\n  } else if (value !== oldValue) {\n    el.checked = looseEqual(value, getCheckboxValue(el, true))\n  }\n}\n\nvModelRadio\n\n和checkbox相比绑定事件内的处理更少了\n\nexport const vModelRadio: ModelDirective = {\n  created(el, { value }, vnode) {\n    el.checked = looseEqual(value, vnode.props!.value)\n    el._assign = getModelAssigner(vnode)\n    addEventListener(el, 'change', () => {\n      el._assign(getValue(el))\n    })\n  },\n  beforeUpdate(el, { value, oldValue }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    if (value !== oldValue) {\n      el.checked = looseEqual(value, vnode.props!.value)\n    }\n  }\n}\n\nvModelSelect\n\nexport const vModelSelect: ModelDirective = {\n  //  value need to be deep traversed\n  deep: true,\n  created(el, { value, modifiers: { number } }, vnode) {\n    // 是否是Set类型\n    const isSetModel = isSet(value)\n    addEventListener(el, 'change', () => {\n      // 选中的值\n      const selectedVal = Array.prototype.filter\n      \t// filter筛选出所有selected的对象\n        .call(el.options, (o: HTMLOptionElement) => o.selected)\n        .map((o: HTMLOptionElement) =>\n             // 取出其中的值，需要是数字的转换为number类型\n          number ? toNumber(getValue(o)) : getValue(o)\n        )\n      // 调用\n      el._assign(\n        el.multiple\n          ? isSetModel\n            ? new Set(selectedVal)\n            : selectedVal\n          : selectedVal[0]\n      )\n    })\n    el._assign = getModelAssigner(vnode)\n  },\n  // set value in mounted & updated because  relies on its children\n  // s.\n  mounted(el, { value }) {\n    setSelected(el, value)\n  },\n  beforeUpdate(el, _binding, vnode) {\n    // 更新绑定回调函数\n    el._assign = getModelAssigner(vnode)\n  },\n  updated(el, { value }) {\n    setSelected(el, value)\n  }\n}\n\n// 设置选中\nfunction setSelected(el: HTMLSelectElement, value: any) {\n  // 是否多选\n  const isMultiple = el.multiple\n\n  // 。。。\n\n  for (let i = 0, l = el.options.length; i  -1\n      } else {\n        // Set类型\n        option.selected = value.has(optionValue)\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        // 重新覆盖当前对象上的selectedIndex\n        if (el.selectedIndex !== i) el.selectedIndex = i\n        return\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    // 默认值-1\n    el.selectedIndex = -1\n  }\n}\n\nvOn\n\n用于绑定元素事件\n\nv-on官方内置了一些修饰符，可以一定程度上减少我们平时需要加的处理代码\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta']\n\ntype KeyedEvent = KeyboardEvent | MouseEvent | TouchEvent\n\nconst modifierGuards: Record void | boolean\n> = {\n  stop: e => e.stopPropagation(),\n  prevent: e => e.preventDefault(),\n  self: e => e.target !== e.currentTarget,\n  ctrl: e => !(e as KeyedEvent).ctrlKey,\n  shift: e => !(e as KeyedEvent).shiftKey,\n  alt: e => !(e as KeyedEvent).altKey,\n  meta: e => !(e as KeyedEvent).metaKey,\n  left: e => 'button' in e && (e as MouseEvent).button !== 0,\n  middle: e => 'button' in e && (e as MouseEvent).button !== 1,\n  right: e => 'button' in e && (e as MouseEvent).button !== 2,\n  exact: (e, modifiers) =>\n    systemModifiers.some(m => (e as any)[${m}Key] && !modifiers.includes(m))\n}\n\nvShow\n\nHello!\n\nv-show在开发过程中也是频繁使用的指令，用于控制元素的显示隐藏\n\ntrue: display:block;\nfalse: display:none;\n\n生命周期处理\n\nbeforeMount:记录下原始display的状态，并且设置元素的display的值\nmounted:处理transition相关的业务\nupdated:更新元素的display的值\nbeforeUnmount:更新元素的display的值\n\nexport const vShow: ObjectDirective = {\n  beforeMount(el, { value }, { transition }) {\n    // 记录元素原始状态\n    el._vod = el.style.display === 'none' ? '' : el.style.display\n    if (transition && value) {\n      transition.beforeEnter(el)\n    } else {\n      // 更新\n      setDisplay(el, value)\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el)\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    if (!value === !oldValue) return\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el)\n        setDisplay(el, true)\n        transition.enter(el)\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false)\n        })\n      }\n    } else {\n      // 更新\n      setDisplay(el, value)\n    }\n  },\n  beforeUnmount(el, { value }) {\n    // 更新\n    setDisplay(el, value)\n  }\n}\n\n// 更新元素display的值，true为原始状态，false为none\nfunction setDisplay(el: VShowElement, value: unknown): void {\n  el.style.display = value ? el._vod : 'none'\n}\n",
        "tags": [
            "vue3"
        ]
    },
    {
        "uri": "/posts/2022/07/compiler-parse/",
        "title": "vue3 -- @vue/compiler-core parse处理整体流程",
        "content": "\n@vue/compiler-core\n\n>   \"version\": \"3.2.37\"\n\n> packages/compiler-core/src/parse.ts\n\nbaseParse\n\nparseChildren\n\nparseChildren采用了一种从前向后匹配的机制，不断的去改写context.source上的字符串\n\n其中parseChildren是处理核心，最终parseElement也会走回到这里，逻辑有点像vue patch的处理逻辑\n\nparseInterpolation\n\n解析插值操作\n\nfunction parseInterpolation(\n  context: ParserContext,\n  mode: TextModes\n): InterpolationNode | undefined {\n  // 拿到插值表达式的开始符和结束符\n  const [open, close] = context.options.delimiters\n\n  // 除去开始符，开始计算结束符的索引\n  const closeIndex = context.source.indexOf(close, open.length)\n  // 索引是-1，说明没有结束符，报错\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.XMISSINGINTERPOLATION_END)\n    return undefined\n  }\n\n  // 拿到当前上下文的开始位置，这是包括开始符和结束符的\n  const start = getCursor(context)\n  // 修改source 字符串，从头删除 开始符长度\n  advanceBy(context, open.length)\n  // 储存常量，开始符和结束符的位置，这个时候开始符和结束符的位置是一致的\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  // 计算出开始符和结束符直接的字符长度\n  const rawContentLength = closeIndex - open.length\n  // 截取出对应长度，其实就是插值表达式了\n  const rawContent = context.source.slice(0, rawContentLength)\n  // 解析出整个插值表达式的字符串，并且修改source上的剩余字符串\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  // 字符串trim\n  const content = preTrimContent.trim()\n  // 开头的偏移量， 说明有空格\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    // 修改innerStart上的对应偏移参数\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  // 计算出结尾的偏移量\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  // 对应修改innerEnd上的对应偏移参数\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  // 同时修改source上的字符串，去除尾部标签长度的字符串\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set isConstant to false by default and will decide in transformExpression\n      constType: ConstantTypes.NOT_CONSTANT,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n",
        "tags": [
            "vue3",
            "@vue/compiler-sfc"
        ]
    },
    {
        "uri": "/posts/2022/07/compiler-sfc-2/",
        "title": "vue3 -- @vue/compiler-sfc 工具源码解读",
        "content": "\n@vue/compiler-sfc\n\n>   \"version\": \"3.2.37\"\n\nparse 源码\n\n接收2个参数\n\nsource: 传入的模版文件的内容\noption: 解析配置\n\nexport function parse(\n  source: string,\n  {\n    sourceMap = true,\n    filename = DEFAULT_FILENAME,\n    sourceRoot = '',\n    pad = false,\n    ignoreEmpty = true,\n    compiler = CompilerDOM\n  }: SFCParseOptions = {}\n): SFCParseResult {\n  // ....\n}\n\n构造出对应文件的key，以便缓存处理。 这里的缓存在不同的平台用不同的手段去实现\n\nconst sourceToSFC = createCache()\n\n// .....\n\n// 构造出唯一的key，用作缓存使用\n  const sourceKey =\n    source + sourceMap + filename + sourceRoot + pad + compiler.parse\n  const cache = sourceToSFC.get(sourceKey)\n  // 存在缓存的情况下直接返回\n  if (cache) {\n    return cache\n  }\n\n构造出一个原始的descriptor对象\n\n  // 构造最终返回的descriptor对象\n  const descriptor: SFCDescriptor = {\n    filename,\n    source, // 源文件内容\n    template: null,\n    script: null,\n    scriptSetup: null,\n    styles: [],\n    customBlocks: [],\n    cssVars: [],\n    slotted: false,\n    shouldForceReload: prevImports => hmrShouldReload(prevImports, descriptor)\n  }\n\n使用编译器进行解析\n\n// 通过编译器最终编译后的结果\nconst ast = compiler.parse(source, {\n  // ....\n})\n\n拿到ast的结果后进行循环处理\n\n拿到子元素的不同类型，通过switch case分别进行处理\n\ntemplate\nscript\nstyle\n\nast.children.forEach(node => {\n  if (node.type !== NodeTypes.ELEMENT) {\n    return\n  }\n  // .....\n  switch (node.tag) {\n    case 'template':\n      // template 标签\n      if (!descriptor.template) {\n        // 对descriptor的template进行赋值\n        const templateBlock = (descriptor.template = createBlock(\n          node,\n          source,\n          false\n        ) as SFCTemplateBlock)\n        templateBlock.ast = node\n\n        // warn against 2.x\n        // 不再支持functional写法\n        if (templateBlock.attrs.functional) {\n          const err = new SyntaxError()\n          err.loc = node.props.find(p => p.name === 'functional')!.loc\n          errors.push(err)\n        }\n      } else {\n        // 多个template标签抛错\n        errors.push(createDuplicateBlockError(node))\n      }\n      break\n    case 'script':\n      const scriptBlock = createBlock(node, source, pad) as SFCScriptBlock\n      // 是否是setup语法，包含setup属性\n      const isSetup = !!scriptBlock.attrs.setup\n      if (isSetup && !descriptor.scriptSetup) {\n        // 写入scriptSetup\n        descriptor.scriptSetup = scriptBlock\n        break\n      }\n      if (!isSetup && !descriptor.script) {\n        // 写入script\n        descriptor.script = scriptBlock\n        break\n      }\n      errors.push(createDuplicateBlockError(node, isSetup))\n      break\n    case 'style':\n      // 写入styles属性\n      const styleBlock = createBlock(node, source, pad) as SFCStyleBlock\n\t\t\t// ....\n      descriptor.styles.push(styleBlock)\n      break\n    default:\n      descriptor.customBlocks.push(createBlock(node, source, pad))\n      break\n  }\n})\n\n对于css内容的二次处理，包括css中的变量绑定，样式的深层覆盖等问题\n\n// parse CSS vars\n// 解析css中绑定参数\ndescriptor.cssVars = parseCssVars(descriptor)\n\n// check if the SFC uses :slotted\n// 检查css中是否包含slotted, 即插槽的样式覆盖\nconst slottedRE = /(?:::v-|:)slotted\\(/\ndescriptor.slotted = descriptor.styles.some(\n  s => s.scoped && slottedRE.test(s.content)\n)\n\n处理完毕后加入缓存并且返回对象\n\nconst result = {\n  descriptor,\n  errors\n}\nsourceToSFC.set(sourceKey, result)\nreturn result\n\ncompileTemplate\n\n> packages/compiler-sfc/src/compileTemplate.ts\n\n对于编译处理器的判断处理，如果用户是在浏览器侧使用，需要手动传入预处理器preprocess\n\nif (\n  (ESM_BROWSER || GLOBAL) &&\n  preprocessLang &&\n  !preprocessCustomRequire\n) {\n  throw new Error(\n    [@vue/compiler-sfc] Template preprocessing in the browser build must  +\n      provide the \\preprocessCustomRequire\\ option to return the in-browser  +\n      version of the preprocessor in the shape of { render(): string }.\n  )\n}\n\nconst preprocessor = preprocessLang\n  ? preprocessCustomRequire\n    ? preprocessCustomRequire(preprocessLang)\n    : ESM_BROWSER\n    ? undefined\n    : consolidate[preprocessLang as keyof typeof consolidate]\n  : false\n\n主处理函数还是doCompileTemplate\n\ndoCompileTemplate\n\n主编译函数还是个黑盒函数，被封装在compiler中了，后续再看\n\nlet { code, ast, preamble, map } = compiler.compile(source, {\n  mode: 'module', // 模块的形式\n  prefixIdentifiers: true,\n  hoistStatic: true, // 静态节点提升\n  cacheHandlers: true,\n  ssrCssVars:\n    ssr && ssrCssVars && ssrCssVars.length\n      ? genCssVarsFromList(ssrCssVars, shortId, isProd, true)\n      : '',\n  scopeId: scoped ? longId : undefined, // scoped时，会加入一个自定义id\n  slotted,\n  sourceMap: true,\n  ...compilerOptions,\n  nodeTransforms: nodeTransforms.concat(compilerOptions.nodeTransforms || []),\n  filename,\n  onError: e => errors.push(e),\n  onWarn: w => warnings.push(w)\n})\n\ncompileScript\n\n> packages/compiler-sfc/src/compileScript.ts\n\n取出当前script上的一些常量\n\nconst enableReactivityTransform =\n  !!options.reactivityTransform ||\n  !!options.refSugar ||\n  !!options.refTransform\nconst enablePropsTransform =\n  !!options.reactivityTransform || !!options.propsDestructureTransform\nconst isProd = !!options.isProd\nconst genSourceMap = options.sourceMap !== false\nlet refBindings: string[] | undefined\n\nconst scopeId = options.id ? options.id.replace(/^data-v-/, '') : ''\n// css变量参数\nconst cssVars = sfc.cssVars\n// script上的lang值\nconst scriptLang = script && script.lang\n// scriptSetup上的lang值\nconst scriptSetupLang = scriptSetup && scriptSetup.lang\n// 是否需要ts\nconst isTS =\n  scriptLang === 'ts' ||\n  scriptLang === 'tsx' ||\n  scriptSetupLang === 'ts' ||\n  scriptSetupLang === 'tsx'\n\n整理处理文件内容需要的插件\n\n动态加入jsx插件\n如果需要typescript插件，则插入装饰器插件decorators-legacy\n\n// resolve parser plugins\nconst plugins: ParserPlugin[] = []\nif (!isTS || scriptLang === 'tsx' || scriptSetupLang === 'tsx') {\n  plugins.push('jsx')\n} else {\n  // If don't match the case of adding jsx, should remove the jsx from the babelParserPlugins\n  if (options.babelParserPlugins)\n    options.babelParserPlugins = options.babelParserPlugins.filter(\n      n => n !== 'jsx'\n    )\n}\nif (options.babelParserPlugins) plugins.push(...options.babelParserPlugins)\nif (isTS) {\n  plugins.push('typescript')\n  if (!plugins.includes('decorators')) {\n    plugins.push('decorators-legacy')\n  }\n}\n\ncompileStyle\n\n> packages/compiler-sfc/src/compileStyle.ts\n\ndoCompileStyle\n\n使用css预处理器进行处理\n\nconst preprocessor = preprocessLang && processors[preprocessLang]\nconst preProcessedSource = preprocessor && preprocess(options, preprocessor)\n\n在css处理插件处加入一些内置插件\n\n在插件列表头部加入css中变量处理插件\n如果需要trim， 加入trim插件\n如果需要scoped， 加入scoped插件\n如果需要模块的方式，加入模块处理的插件\n\nconst plugins = (postcssPlugins || []).slice()\nplugins.unshift(cssVarsPlugin({ id: shortId, isProd }))\nif (trim) {\n  plugins.push(trimPlugin())\n}\nif (scoped) {\n  plugins.push(scopedPlugin(longId))\n}\nlet cssModules: Record | undefined\nif (modules) {\n  if (GLOBAL || ESM_BROWSER) {\n    throw new Error(\n      '[@vue/compiler-sfc] modules option is not supported in the browser build.'\n    )\n  }\n  if (!options.isAsync) {\n    throw new Error(\n      '[@vue/compiler-sfc] modules option can only be used with compileStyleAsync().'\n    )\n  }\n  plugins.push(\n    postcssModules({\n      ...modulesOptions,\n      getJSON: (_cssFileName: string, json: Record) => {\n        cssModules = json\n      }\n    })\n  )\n}\n\n使用postcss加上所有的插件，对内容进行处理\n\ntry {\n  result = postcss(plugins).process(source, postCSSOptions)\n\n  // In async mode, return a promise.\n  if (options.isAsync) {\n    return result\n      .then(result => ({\n        code: result.css || '',\n        map: result.map && result.map.toJSON(),\n        errors,\n        modules: cssModules,\n        rawResult: result,\n        dependencies: recordPlainCssDependencies(result.messages)\n      }))\n      .catch(error => ({\n        code: '',\n        map: undefined,\n        errors: [...errors, error],\n        rawResult: undefined,\n        dependencies\n      }))\n  }\n\n  recordPlainCssDependencies(result.messages)\n  // force synchronous transform (we know we only have sync plugins)\n  code = result.css\n  outMap = result.map\n} catch (e: any) {\n  errors.push(e)\n}\n",
        "tags": [
            "vue3",
            "@vue/compiler-sfc"
        ]
    },
    {
        "uri": "/posts/2022/07/compiler-sfc/",
        "title": "vue3 -- @vue/compiler-sfc 工具解读",
        "content": "\n@vue/compiler-sfc\n\n>   \"version\": \"3.2.37\"\n\nSFC是vue中重要的一环，也是vue3中对于静态节点进行缓存提升的重要位置\n\nSFC  -- single file Component 单文件组件，以.vue进行结尾，这个文件浏览器也不会识别，最终也是要被转换成js代码\n\nSFC中包含三块，template、script、style等三块代码，分别表示模版、脚本、样式三块\n\n@vue/compiler-sfc的作用就是把单文件组件编译成为js代码\n\nparse\n\n下面就看一看具体的使用\n\n新建一个Foo.vue组件\n\nimport { defineComponent, ref } from 'vue'\nexport default defineComponent({\n    name: 'foo',\n    setup() {\n        return {\n            name: ref('jack')\n        }\n    }\n})\n\ninput {\n    color: #333;\n}\n\n组件同时包括template、script、style三块\n\n新建一个nodejs脚本\n\nconst { parse } = require(\"@vue/compiler-sfc\")\nconst fs = require(\"fs\")\nfs.readFile(\"./foo.vue\", (err, data) => {\n\n    let parsed = parse(data.toString(), {\n        filename: 'foo.vue'\n    })\n    console.log('parsed', parsed);\n\n})\n\n用fs读取到文件的内容后，使用parse解析, 最终会返回一个对象\n\n{\n  descriptor: {\n    filename: 'foo.vue',\n    source: '\\n' +\n      '    \\n' +\n      '\\n' +\n      \"\\n\" +\n      \"import { defineComponent, ref } from 'vue'\\n\" +\n      'export default defineComponent({\\n' +\n      \"    name: 'foo',\\n\" +\n      '    setup() {\\n' +\n      '        return {\\n' +\n      \"            name: ref('jack')\\n\" +\n      '        }\\n' +\n      '    }\\n' +\n      '})\\n' +\n      '\\n' +\n      '\\n' +\n      'input {\\n' +\n      '    color: #333;\\n' +\n      '}\\n' +\n      '\\n',\n    template: {\n      type: 'template',\n      content: '\\n    \\n',\n      loc: [Object],\n      attrs: {},\n      ast: [Object],\n      map: [Object]\n    },\n    script: {\n      type: 'script',\n      content: '\\n' +\n        \"import { defineComponent, ref } from 'vue'\\n\" +\n        'export default defineComponent({\\n' +\n        \"    name: 'foo',\\n\" +\n        '    setup() {\\n' +\n        '        return {\\n' +\n        \"            name: ref('jack')\\n\" +\n        '        }\\n' +\n        '    }\\n' +\n        '})\\n',\n      loc: [Object],\n      attrs: [Object],\n      lang: 'ts',\n      map: [Object]\n    },\n    scriptSetup: null,\n    styles: [ [Object] ],\n    customBlocks: [],\n    cssVars: [],\n    slotted: false,\n    shouldForceReload: [Function: shouldForceReload]\n  },\n  errors: []\n}\n\nsetup脚本改造foo.vue\n\nimport { ref } from 'vue'\n\nconst name = ref('jack');\n\ninput {\n    color: #333;\n}\n\nsetup语法编译后的结果\n\n{\n  descriptor: {\n    filename: 'foo.vue',\n    source: '\\n' +\n      '    \\n' +\n      '\\n' +\n      \"\\n\" +\n      \"import { ref } from 'vue'\\n\" +\n      '\\n' +\n      \"const name = ref('jack');\\n\" +\n      '\\n' +\n      '\\n' +\n      'input {\\n' +\n      '    color: #333;\\n' +\n      '}\\n' +\n      '\\n',\n    template: {\n      type: 'template',\n      content: '\\n    \\n',\n      loc: [Object],\n      attrs: {},\n      ast: [Object],\n      map: [Object]\n    },\n    script: null,\n    scriptSetup: {\n      type: 'script',\n      content: \"\\nimport { ref } from 'vue'\\n\\nconst name = ref('jack');\\n\",\n      loc: [Object],\n      attrs: [Object],\n      lang: 'ts',\n      setup: true\n    },\n    styles: [ [Object] ],\n    customBlocks: [],\n    cssVars: [],\n    slotted: false,\n    shouldForceReload: [Function: shouldForceReload]\n  },\n  errors: []\n}\n\n唯一的不同就是编译后的结果从原来的script上迁移到scriptSetup上\n\ncompileTemplate\n\n拿到之前parse后的结果后，需要对template进行进一步的转换，把template结果进一步编译成对应的js vnode函数\n\nlet compileredTemplate = compileTemplate({\n    id: '123',\n    filename: 'foo.vue',\n    source: parsed.descriptor.template.content\n})\nconsole.log('parsed', compileredTemplate);\n\n其中code的值就是最终模版编译的结果\n\n{\n  code: 'import { vModelText as vModelText, withDirectives as withDirectives, openBlock as openBlock, createElementBlock as createElementBlock } from \"vue\"\\n' +\n    '\\n' +\n    'export function render(ctx, cache) {\\n' +\n    '  return withDirectives((openBlock(), _createElementBlock(\"input\", {\\n' +\n    '    type: \"text\",\\n' +\n    '    \"onUpdate:modelValue\": cache[0] || (cache[0] = $event => ((_ctx.name) = $event))\\n' +\n    '  }, null, 512 /* NEED_PATCH */)), [\\n' +\n    '    [vModelText, ctx.name]\\n' +\n    '  ])\\n' +\n    '}',\n  ast: {\n    type: 0,\n    children: [ [Object] ],\n    helpers: [\n      Symbol(vModelText),\n      Symbol(withDirectives),\n      Symbol(openBlock),\n      Symbol(createElementBlock)\n    ],\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: 1,\n    temps: 0,\n    codegenNode: {\n      type: 13,\n      tag: '\"input\"',\n      props: [Object],\n      children: undefined,\n      patchFlag: '512 /* NEED_PATCH */',\n      dynamicProps: undefined,\n      directives: [Object],\n      isBlock: true,\n      disableTracking: false,\n      isComponent: false,\n      loc: [Object]\n    },\n    loc: {\n      start: [Object],\n      end: [Object],\n      source: '\\n    \\n'\n    },\n    filters: []\n  },\n  preamble: '',\n  source: '\\n    \\n',\n  errors: [],\n  tips: [],\n  map: {\n    version: 3,\n    sources: [ 'foo.vue' ],\n    names: [ 'name' ],\n    mappings: ';;;wCACI,oBAAkC;IAA3B,IAAI,EAAC,MAAM;IADtB,6DACgCA,SAAI;;kBAAJA,SAAI',\n    sourcesContent: [ '\\n    \\n' ]\n  }\n}\n\n我们把结果单独拿出来看下\n\nimport { vModelText as vModelText, withDirectives as withDirectives, openBlock as openBlock, createElementBlock as createElementBlock } from \"vue\"\n\nexport function render(ctx, cache) {\n    return withDirectives((openBlock(), _createElementBlock(\"input\", {\n        type: \"text\",\n        \"onUpdate:modelValue\": cache[0] || (cache[0] = $event => ((_ctx.name) = $event))\n    }, null, 512 /* NEED_PATCH */)), [\n        [vModelText, ctx.name]\n    ])\n}\n\n最终返回了一个render函数，这里也就符合预期，vue组件中如果使用js的方式写，可以写一个render函数去渲染组件\n\ncompilerScript\n\n根据parsed的结果来解析脚本部分，compileScript接收2个参数，第一个就是之前parse的结果， 然后再传入相应的option\n\nlet compileredScript = compileScript(parsed.descriptor, {\n    id: '123'\n})\nconsole.log('parsed', compileredScript);\n\n编译后的结果，content就是最终编译出的代码\n\n{\n  type: 'script',\n  content: \"import { defineComponent as _defineComponent } from 'vue'\\n\" +\n    \"import { ref } from 'vue'\\n\" +\n    '\\n' +\n    '\\n' +\n    'export default /#PURE/_defineComponent({\\n' +\n    '  setup(__props, { expose }) {\\n' +\n    '  expose();\\n' +\n    '\\n' +\n    \"const name = ref('jack');\\n\" +\n    '\\n' +\n    'const returned = { name }\\n' +\n    \"Object.defineProperty(returned, '__isScriptSetup', { enumerable: false, value: true })\\n\" +\n    'return returned\\n' +\n    '}\\n' +\n    '\\n' +\n    '})',\n  loc: {\n    source: \"\\nimport { ref } from 'vue'\\n\\nconst name = ref('jack');\\n\",\n    start: { column: 25, line: 4, offset: 86 },\n    end: { column: 1, line: 8, offset: 140 }\n  },\n  attrs: { lang: 'ts', setup: true },\n  lang: 'ts',\n  setup: true,\n  bindings: { ref: 'setup-const', name: 'setup-ref' },\n  imports: [Object: null prototype] {\n    ref: {\n      isType: false,\n      imported: 'ref',\n      source: 'vue',\n      isFromSetup: true,\n      isUsedInTemplate: false\n    }\n  },\n  map: SourceMap {\n    version: 3,\n    file: null,\n    sources: [ 'foo.vue' ],\n    sourcesContent: [\n      '\\n' +\n        '    \\n' +\n        '\\n' +\n        \"\\n\" +\n        \"import { ref } from 'vue'\\n\" +\n        '\\n' +\n        \"const name = ref('jack');\\n\" +\n        '\\n' +\n        '\\n' +\n        'input {\\n' +\n        '    color: #333;\\n' +\n        '}\\n' +\n        '\\n'\n    ],\n    names: [],\n    mappings: ';AAIA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB;;;;;AAFwB;AAGxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;;;'\n  },\n  scriptAst: undefined,\n  scriptSetupAst: [\n    Node {\n      type: 'ImportDeclaration',\n      start: 1,\n      end: 26,\n      loc: [SourceLocation],\n      importKind: 'value',\n      specifiers: [Array],\n      source: [Node]\n    },\n    Node {\n      type: 'VariableDeclaration',\n      start: 28,\n      end: 53,\n      loc: [SourceLocation],\n      declarations: [Array],\n      kind: 'const'\n    }\n  ]\n}\n\ncontent格式化之后的结果， 所以说setup只是语法糖，最终还是以defineComponent去包裹一个对象进行返回的形式\n\nimport { defineComponent as _defineComponent } from 'vue'\nimport { ref } from 'vue'\n\nexport default /#PURE/_defineComponent({\n    setup(__props, { expose }) {\n        expose();\n\n        const name = ref('jack');\n\n        const returned = { name }\n        Object.defineProperty(returned, '__isScriptSetup', { enumerable: false, value: true })\n        return returned\n    }\n\n})\n\ncompileStyle\n\ncompileStyle 即解析SFC style模块的入口函数\n\n由于sfc中style块是可以写多个的，所以parse最终的结果styles其实是个数组\n\n由变量签名也可以看出\n\nexport interface SFCDescriptor {\n  // ....\n  styles: SFCStyleBlock[]\n\n}\n\n这里我们取第一个块打印出来看一下，实际情况下应该是去循环的\n\nlet compileredStyle = compileStyle({\n    source: parsed.descriptor.styles[0].content,\n    scoped: true,\n    id: 'data-v-123'\n})\nconsole.log('parsed', compileredStyle);\n\n编译结果\n\n其中code即是最终的css结果\n\n{\n  code: '\\ninput[data-v-123] {\\n    color: #333;\\n}\\n',\n  map: undefined,\n  errors: [],\n  rawResult: LazyResult {\n    stringified: true,\n    processed: true,\n    result: Result {\n      processor: [Processor],\n      messages: [],\n      root: [Root],\n      opts: [Object],\n      css: '\\ninput[data-v-123] {\\n    color: #333;\\n}\\n',\n      map: undefined,\n      lastPlugin: [Object]\n    },\n    helpers: {\n      plugin: [Function: plugin],\n      stringify: [Function],\n      parse: [Function],\n      fromJSON: [Function],\n      list: [Object],\n      comment: [Function (anonymous)],\n      atRule: [Function (anonymous)],\n      decl: [Function (anonymous)],\n      rule: [Function (anonymous)],\n      root: [Function (anonymous)],\n      document: [Function (anonymous)],\n      CssSyntaxError: [Function],\n      Declaration: [Function],\n      Container: [Function],\n      Processor: [Function],\n      Document: [Function],\n      Comment: [Function],\n      Warning: [Function],\n      AtRule: [Function],\n      Result: [Function],\n      Input: [Function],\n      Rule: [Function],\n      Root: [Function],\n      Node: [Function],\n      default: [Function],\n      result: [Result],\n      postcss: [Function]\n    },\n    plugins: [ [Object], [Object], [Object] ],\n    listeners: {\n      Declaration: [Array],\n      Rule: [Array],\n      AtRule: [Array],\n      OnceExit: [Array]\n    },\n    hasListener: true\n  },\n  dependencies: Set(0) {}\n}\n",
        "tags": [
            "vue3",
            "@vue/compiler-sfc"
        ]
    },
    {
        "uri": "/posts/2022/06/cssVars/",
        "title": "vue -- cssVars css绑定变量",
        "content": "\nVue3 cssVars\n\n>   \"version\": \"3.2.37\"\n\nvue3中单文件SFC有个新特性，就是在css里可以使用变量了\n\n    123\n\nconst color = 'red'\n\n h1 {\n    color: v-bind(color)\n }\n\n具体的代码就是使用v-bind去绑定变量值，这里预览的结果就是h1会显示出红色\n\n查看h1的标签，可以看到\n\ncolor使用的是 css自带的变量var语法进行绑定的\n\n并且把变量值绑定到父元素上，通过js写入到父元素的行内样式里\n\ncss变量绑定分为2个阶段\n\n编译阶段，把变量转换成css var变量语法机制\n运行时阶段，js动态改变父元素上的变量绑定\n\ndoCompileStyle\n\n这个函数是compileStyle的主函数，其主要作用就是把SFC中的css部分编译识别出来\n\n其中也有很多处理代码，最终也是使用postcss去处理\n\n// .....\nconst shortId = id.replace(/^data-v-/, '')\nconst longId = data-v-${shortId}\n\nconst plugins = (postcssPlugins || []).slice()\nplugins.unshift(cssVarsPlugin({ id: shortId, isProd }))\n\n// ....\n\n可以看到其中最第一位的就是在plugins的首位插入了一个插件，就是cssVarsPlugin\n\ncssVarsPlugin\n\n插件中通过正则匹配v-bind在字符串中的位置进行匹配替换\n\nconst vBindRE = /v-bind\\s*\\(/g\n//....\n\nexport const cssVarsPlugin: PluginCreator = opts => {\n  const { id, isProd } = opts!\n  return {\n    postcssPlugin: 'vue-sfc-vars',\n    Declaration(decl) {\n      // rewrite CSS variables\n      const value = decl.value\n      if (vBindRE.test(value)) {\n        // 重置匹配位置到首位\n        vBindRE.lastIndex = 0\n        // 匹配后的字符\n        let transformed = ''\n\n        let lastIndex = 0\n        let match\n\n        while ((match = vBindRE.exec(value))) {\n          // 匹配字符的开始位置\n          const start = match.index + match[0].length\n          const end = lexBinding(value, start)\n          if (end !== null) {\n            const variable = normalizeExpression(value.slice(start, end))\n            transformed +=\n              value.slice(lastIndex, match.index) +\n              var(--${genVarName(id, variable, isProd)})\n            lastIndex = end + 1\n          }\n        }\n        decl.value = transformed + value.slice(lastIndex)\n      }\n    }\n  }\n}\ncssVarsPlugin.postcss = true\n\n最终会在transformed进行字符串拼接， 并且生成一个var(--${genVarName(id, variable, isProd)})字符串，其中genVarname会根据当前组件的id进行生成，生产环境就是用随机字符串生成的\n\nlastIndex会在拼接后向后移动1位\n\n最后css转换后的值，v-bind就被替换成css的var()语法\n\nlexBinding\n\nlexBinding函数要结合上下文来看，v-bind的括号中变量是有多重形式的\n\n其中可能会有括号\n\nfont-weight: v-bind(\"count.toString(\");\nfont-weight: v-bind(xxx);\n\n官方代码中就是使用for循环，结合switch\\case, 最终找到最后一个),返回索引值，也就是end值\n\nfunction lexBinding(content: string, start: number): number | null {\n  let state: LexerState = LexerState.inParens\n  let parenDepth = 0\n\n  for (let i = start; i  0) {\n            parenDepth--\n          } else {\n            return i\n          }\n        }\n        break\n      case LexerState.inSingleQuoteString:\n        if (char === ') {\n          state = LexerState.inParens\n        }\n        break\n      case LexerState.inDoubleQuoteString:\n        if (char === \") {\n          state = LexerState.inParens\n        }\n        break\n    }\n  }\n  return null\n}\n\nnormalizeExpression\n\n传入的是context截取的从开始到结束的字符串\n\n如果是'/\",返回去除的字符串\n\nfunction normalizeExpression(exp: string) {\n  exp = exp.trim()\n  if (\n    (exp[0] === ' && exp[exp.length - 1] === ') ||\n    (exp[0] === \" && exp[exp.length - 1] === \")\n  ) {\n    return exp.slice(1, -1)\n  }\n  return exp\n}\n\ngenCssVarsCode\n\n编译后要去动态响应值的变化，就必然要通过js去控制css的值，这里通过genCssVarsCode函数去生存响应的代码\n\nvars 通过编译后搜集的变量名\nbindings 当前组件中script暴露的变量\nid 当前组件的id\n\nexport function genCssVarsCode(\n  vars: string[],\n  bindings: BindingMetadata,\n  id: string,\n  isProd: boolean\n) {\n  // 根据当前组件css搜集的变量名，生成以逗号分隔的字符串，最后用大括号包围\n  const varsExp = genCssVarsFromList(vars, id, isProd)\n  // 组装成一个对象，其中content就是之前生成的字符串\n  const exp = createSimpleExpression(varsExp, false)\n\n  // ....\n\n  const transformed = processExpression(exp, context)\n  // ... 这里是伪代码， 中间还有其他判断\n  const transformedString = transformed.content\n\n  // 最终会生成一个字符串\n  return ${CSSVARSHELPER}(ctx => (${transformedString}))\n}\n\n我们把中间的变量替换过来，就是\n\n> \\useCssVars(\\ctx => ({\n>\n> // ..... 中间就是css的动态变量的代码\n>\n> }))\n\nuseCssVars\n\nwatchPostEffect是在组件更新之后调用\n\n同时在onMounted钩子函数内，使用MutationObserver监听父元素下的子元素变化，只要子元素发生变化，都会调用setVars函数\n\nexport function useCssVars(getter: (ctx: any) => Record) {\n  if (!BROWSER && !TEST) return\n\n  const instance = getCurrentInstance()\n  /* istanbul ignore next */\n  if (!instance) {\n    DEV &&\n      warn(useCssVars is called without current active component instance.)\n    return\n  }\n\n  const setVars = () =>\n    setVarsOnVNode(instance.subTree, getter(instance.proxy!))\n  watchPostEffect(setVars)\n  onMounted(() => {\n    const ob = new MutationObserver(setVars)\n    ob.observe(instance.subTree.el!.parentNode, { childList: true })\n    onUnmounted(() => ob.disconnect())\n  })\n}\n\nsetVarsOnVNode\n\n根据vode向上递归，找到非组件的父元素，要知道useCssVars是在运行时执行的，所以就是你写的html 元素节点\n\n最后就是把属性写入到父元素的style属性内\n\nfunction setVarsOnVNode(vnode: VNode, vars: Record) {\n  if (FEATURE_SUSPENSE && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\n    const suspense = vnode.suspense!\n    vnode = suspense.activeBranch!\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch!, vars)\n      })\n    }\n  }\n\n  // drill down HOCs until it's a non-component vnode\n  // vnode 向上递归，直到vnode不存在component属性\n  while (vnode.component) {\n    vnode = vnode.component.subTree\n  }\n\n  // 设定属性值\n  if (vnode.shapeFlag & ShapeFlags.ELEMENT && vnode.el) {\n    setVarsOnNode(vnode.el as Node, vars)\n  } else if (vnode.type === Fragment) {\n    // 如果是Fragment，递归调用\n    ;(vnode.children as VNode[]).forEach(c => setVarsOnVNode(c, vars))\n  } else if (vnode.type === Static) {\n    // 静态节点\n    let { el, anchor } = vnode\n    while (el) {\n      setVarsOnNode(el as Node, vars)\n      if (el === anchor) break\n      el = el.nextSibling\n    }\n  }\n}\n\nfunction setVarsOnNode(el: Node, vars: Record) {\n  // 根据nodeType, 如果node是元素属性\n  if (el.nodeType === 1) {\n    const style = (el as HTMLElement).style\n    // 使用setProperty\n    for (const key in vars) {\n      style.setProperty(--${key}, vars[key])\n    }\n  }\n}\n",
        "tags": [
            "vue3"
        ]
    },
    {
        "uri": "/posts/2022/05/elementui-tab/",
        "title": "elementui Tab样式改造",
        "content": "\n\n对于ElementUI样式进行改造\n\n.#{$prefix}-field-drawer {\n  > .el-drawer__header {\n    background-color: var(--theme);\n    padding-bottom: 20px;\n    color: #fff;\n  }\n\n  > .el-drawer__body {\n    padding-left: 8px;\n    padding-right: 8px;\n  }\n\n  .flow-field-tab {\n    .el-tabs__nav-wrap {\n      padding-bottom: 10px;\n\n      &::after {\n        background-color: var(--theme);\n      }\n    }\n    .el-tabs__active-bar {\n      display: none;\n    }\n\n    .el-tabs__item {\n      padding: 6px 12px;\n      height: unset;\n      line-height: unset;\n    }\n\n    .el-tabs__item.is-active {\n      background-color: #e5edf3;\n      border-radius: 5px;\n      color: #6c95ca;\n    }\n\n    .field-title {\n      font-size: 16px;\n      font-weight: 500;\n      color: #333333;\n      line-height: 22px;\n      margin-bottom: 20px;\n    }\n\n    .field-table {\n      .el-radio__label {\n        display: none;\n      }\n    }\n  }\n}\n",
        "tags": [
            "elementui"
        ]
    },
    {
        "uri": "",
        "content": "\n\ntitle: \"vue2 -- 核心diff 源码解读\"\ndate: 2022-01-11T10:18:05+08:00\ndraft: true\ntags: [\"vue\", \"javascript\"]\n\nvue2 组件diff过程\npatchVnode\n\n打补丁过程\n\nfunction patchVnode(\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n) {\n    // 旧node和新node相等，直接退出\n    if (oldVnode === vnode) {\n        return;\n    }\n\n    var elm = (vnode.elm = oldVnode.elm);\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n\n    // 如果新vnode没有text\n    if (isUndef(vnode.text)) {\n        // 新老vnode都存在children的情况下\n        if (isDef(oldCh) && isDef(ch)) {\n            if (oldCh !== ch) { // 并且不相等\n                // 走updateChildren 逻辑\n                updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n            }\n        } else if (isDef(ch)) {\n            // 新vnode存在children， 老的没有children\n            // 先清除text文本\n            if (isDef(oldVnode.text)) {\n                nodeOps.setTextContent(elm, \"\");\n            }\n            // 在生产新的vnode\n            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n            // 老的vnode下是children， 清空数组\n            removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n            // 老的vnode下是text， 直接清空\n            nodeOps.setTextContent(elm, \"\");\n        }\n    } else if (oldVnode.text !== vnode.text) {\n        // 如果新vnode有text， 直接调用dom api 更新文本\n        nodeOps.setTextContent(elm, vnode.text);\n    }\n}\n\n// 更新子元素\nfunction updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    {\n        // 检查重复key并提示到控制台\n        checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx  oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        // 把剩下的从start到end的数据遍历插入到对应的位置\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) { // 数组变短，新的数组开始结束指针提前相遇\n        // 遍历删除掉旧数组中不需要得到元素\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n}\n",
        "tags": []
    },
    {
        "uri": "/posts/2022/05/commons-chunk-plugin/",
        "title": "webpack 代码分片",
        "content": "\nwebpack CommonsChunkPlugin\n\n代码分片是webpack中重要的优化手段，对于一个比较大的chunk，有必要提取出当前chunk中依赖的不经常变化的库\n\nusage\n\nnew webpack.optimize.CommonsChunkPlugin()\n\n配置项\n\n{\n\t name: string, // 提取出来的chunk的名称\n   names: string[], // 名称输入字符串数组时，相当于多次调用本插件\n   filename: string, //\n   minSize: number,\n   minChunks: number|Infinity|function(module, count) => boolean, // 最少引用次数\n   chunks: string[], // 这里的chunks， 和入口部分的chunk一一对应，如果出现在其中，就会被单独提取出来，如果省略，即所有入口chunk都会被选择\n   children: boolean,\n   deepChildren: boolean,\n   async: boolean|string,\n}\n",
        "tags": [
            "webpack"
        ]
    },
    {
        "uri": "/posts/2022/05/principle/",
        "title": "webpack 打包原理",
        "content": "\nwebpack\n\n知识点\n\n通过入口文件循环遍历每个模块，把对应的模块交给对应的loader去处理, 所以webpack建议把你开发应用所有需要的资源都通过js去引用。\n\nLoader机制是webpack最核心的机制，可以通过loader加载前端需要的任何资源\n\nloader的执行顺序是从后往前\nloader处理特殊类型资源文件的加载，plugin实现各种自动化的构建任务，扩展打包\nloader只在模块加载环节使用，plugin覆盖全webpack生命周期\n\n工作原理\n\nwebpack cli启动打包流程\n载入webpack核心模块，创建Compiler对象\n使用Compiler对象开始编译整个项目\n从入口文件开始，解析模块依赖，形成依赖关系树\n递归依赖树，将每个模块交给对应的Loader处理\n合并Loader处理完的结果，将结果打包输出到dist目录\n",
        "tags": []
    },
    {
        "uri": "/posts/2021/10/webpack-loader-plugin/",
        "title": "Webpack Loader Plugin",
        "content": "\nwebpack Loaders and Plugins different\n\nLoaders:\n\nLoaders work at the individual file level during or before the bundle is generated.\n\nloader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中\n\n处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行\n\n第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码\n\nmodule.exports = function(source) {\n    // console.log('demo-loader: ', source)\n    // 把foo 替换成 Fgg\n    return source.replace(/foo/g, 'Fgg')\n}\n\nPlugins:\n\nPlugins work at bundle or chunk level and usually work at the end of the bundle generation process. Plugins can also modify how the bundles themselves are created. Plugins have more powerful control than loaders.\n\n在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果\n\nclass BasicPlugin {\n    // 在构造函数中获取用户给该插件传入的配置\n    constructor(options) {\n    }\n\n    // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n    apply(compiler) {\n        compiler.hooks.run.tap('Demo Plugin', (compilation) => {\n            console.log('webpack 构建正在启动！');\n        });\n    }\n}\n\n// 导出 Plugin\nmodule.exports = BasicPlugin;\n`",
        "tags": [
            "js",
            "webpack"
        ]
    },
    {
        "uri": "/posts/2022/06/concept/",
        "title": "webrtc 相关概念",
        "content": "\nwebRTC传输技术\n\nRTP\n\nRTP（Real-time Transport Protocol，实时传输协议）通过IP网络实时传输音频和视频。RTP常用于流媒体服务的通信系统，例如网络电话、WebRTC视频电话会议、电视服务等.\n\n具有较低的延时。\n数据包在网络传输的过程中可能会丢失，到达对等端的顺序也可能发生变化。对等端收到RTP数据包后，需要根据数据包的序列号和时间戳进行重新组合。\n支持多播（multicast），尽管目前WebRTC还没有使用这个特性，但是在海量用户通话场景，这个特性就变得很重要。\n\nRTP会为每个媒体流建立一个会话，即音频和视频流使用单独的RTP会话，这样接收端就能选择性地接收媒体流。RTP使用的端口号为偶数，每个关联的RTCP端口为下一个较高的奇数，端口号范围为1024～65535。\n\nRTCP\n\nRTCP（RTP Control Protocol）是实时传输协议（RTP）的姊妹协议，其基本功能和数据包结构在RFC 3550中定义。RTCP为RTP会话提供带外统计信息和控制信息，与RTP协作提供多媒体数据的传输和打包功能，其本身不传输任何媒体数据。\n\nRTP通常在偶数UDP端口上发送，而RTCP消息将在下一个更高的奇数端口发送。\n\nWebRTC使用的是SRTP。SRTP是RTP的一个配置文件，旨在为单播和多播应用程序中的RTP数据提供加密、消息身份验证和完整性以及重放攻击保护等安全功能。\n\nSRTP和SRTCP默认的加密算法是AES，攻击者虽然无法解密数据，但可以伪造或重放以前发送的数据。因此，SRTP标准还提供了确保数据完整性和安全性的方法。\n\nSDP\n\nSDP（Session Description Protocol）是用于描述媒体信息的协议，以文本格式描述终端功能和首选项。\n\nSDP广泛用于会话启动协议（SIP）、RTP和实时流协议（RSP）。\n",
        "tags": null
    },
    {
        "uri": "/posts/2022/06/windows-jenkins/",
        "title": "windows下docker运行jenkins",
        "content": "\nwindows下docker运行jenkins\n\nimage\n\n> docker pull jenkinsci/blueocean\n\nrun\n\n> docker run --name jenkinsci-blueocean -u root --rm  -d -p 7005:8080 -p 50000:50000 -v D:\\workspace\\jenkinsData:/var/jenkins_home jenkinsci/blueocean",
        "tags": null
    }
]