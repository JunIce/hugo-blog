---
title: "算法基础知识"
date: 2022-08-02T07:13:09+08:00
tags: ["算法基础"]
categories: ["algorithm"]
draft: false
---





## 队列和双端队列

双端队列是一种将栈的原则和队列的原则混合在一起的数据结构。

### 队列

FIFO（First Input First Output）， 先进先出，新添加的元素在队列的尾部，从顶部移除元素。

最常见的例子就是排队。

```typescript
class Queue {
    _count: number;
    _first: number;
    _items: {
        [key: number]: any
    };
    constructor() {
        this._count = 0;
        this._first = 0;
        this._items = {};
    }

    pop() {
        const item = this._items[this._first];
        delete this._items[this._first];
        this._first++;
        return item;
    }

    push(element: any) {
        this._count++;
        this._items[this._count] = element;
    }

    peek() {
        if (this.isEmpty()) return undefined;

        return this._items[this._first];
    }

    size() {
        return this._count - this._first;
    }

    isEmpty() {
        return this.size() === 0;
    }
}
```



### 双端队列

是一种允许我们同时从前端和后端添加和移除元素的特殊队列。



```typescript
class Deque {
    _count: number;
    _first: number;
    _items: {
        [key: number]: any
    };
    constructor() {
        this._count = 0;
        this._first = 0;
        this._items = {};
    }

    addFront(element: any) {
        if (this.isEmpty()) {
            this.addBack(element)
        } else if(this._first > 0) {
            this._first--;
            this._items[this._first] = element;
        } else {
            for (let i = this._count; i > 0;i--) {
                this._items[i] = this._items[i-1];
            }
            this._first = 0;
            this._items[this._first] = element;
        }
    }

    addBack(element: any) {
        this._count++;
        this._items[this._count] = element;
    }

    removeFront() {

    }

    removeBack() {
        const item = this._items[this._first];
        delete this._items[this._first];
        this._first++;
        return item;
    }

    peekFront() {
        if (this.isEmpty()) return undefined;

        return this._items[this._first];
    }

    peekBack() {
        return this._items[this._count];
    }

    size() {
        return this._count - this._first;
    }

    isEmpty() {
        return this.size() === 0;
    }
}
```





## 链表

链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。



![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fec67b98dc4addb622ef025afeaabc~tplv-k3u1fbpfcp-watermark.image?)



在数组中，我们可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，则需要从**起点（表头**
**）开始迭代**链表直到找到所需的元素。



```typescript
class LinkedList {
    head: LNode | null;
    equalsFn: Function;
    count: number;
    constructor(fn: Function) {
        this.count = 0;
        this.equalsFn = fn;
        this.head = null;
    }

    push(element: any) {
        const node = new LNode(element);
        this.count++;

        if (this.head) {
            let current = this.head.next;
            while (current?.next) {
                current = current.next;
            }
            current!.next = element;
        } else {
            this.head = node;
        }
    }

    insert(element: any, position: number) {
        if (position < 0) {
            position = 0;
        }

        if (position > this.count) {
            position = this.count + 1;
        }

        let node = this.head;

        if (!node) return undefined;

        for (let i = 0; i <= position; i++) {
            node = node?.next!;
        }

        const insertNode = new LNode(element);

        insertNode.next = node.next;
        node!.next = insertNode!;

        this.count++;
    }

    getElementAt(index: number) {
        if (index >= 0 && index <= this.count) {
            let node = this.head;
            for (let i = 0; i < index && node; i++) {
                node = node.next!;
            }
            return node;
        } else {
            return undefined;
        }
    }

    remove(element: any) {
        const index = this.indexOf(element);
        if (index > -1) {
            this.removeAt(index)
            this.count--;

        }
    }

    indexOf(element: any) {
        if (!element) return -1;
        let node = this.head;
        for (let i = 0; i < this.count; i++) {
            if (node?.node === element) {
                return i
            } else {
                node = node?.next!
            }
        }

        return -1
    }

    removeAt(position: number) {
        if (position < 0 || position > this.count) return

        let node = this.head;
        for (let i = 0; i <= position; i++) {
            node = node?.next!
        }

        const next = node?.next;
        node!.next = next?.next;
    }

    isEmpty() {
        return this.count === 0;
    }

    size() {
        return this.count;
    }
}

class LNode {
    node: any;
    next: LNode | undefined;

    constructor(element: any) {
        this.node = element;
        this.next = undefined;
    }
}

```

