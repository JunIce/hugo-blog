---
title: "算法基础知识"
date: 2022-08-02T07:13:09+08:00
tags: ["算法基础"]
categories: ["algorithm"]
draft: false
---





## 队列和双端队列

双端队列是一种将栈的原则和队列的原则混合在一起的数据结构。

### 队列

FIFO（First Input First Output）， 先进先出，新添加的元素在队列的尾部，从顶部移除元素。

最常见的例子就是排队。

```typescript
class Queue {
    _count: number;
    _first: number;
    _items: {
        [key: number]: any
    };
    constructor() {
        this._count = 0;
        this._first = 0;
        this._items = {};
    }

    pop() {
        const item = this._items[this._first];
        delete this._items[this._first];
        this._first++;
        return item;
    }

    push(element: any) {
        this._count++;
        this._items[this._count] = element;
    }

    peek() {
        if (this.isEmpty()) return undefined;

        return this._items[this._first];
    }

    size() {
        return this._count - this._first;
    }

    isEmpty() {
        return this.size() === 0;
    }
}
```



### 双端队列

是一种允许我们同时从前端和后端添加和移除元素的特殊队列。



```typescript
class Deque {
    _count: number;
    _first: number;
    _items: {
        [key: number]: any
    };
    constructor() {
        this._count = 0;
        this._first = 0;
        this._items = {};
    }

    addFront(element: any) {
        if (this.isEmpty()) {
            this.addBack(element)
        } else if(this._first > 0) {
            this._first--;
            this._items[this._first] = element;
        } else {
            for (let i = this._count; i > 0;i--) {
                this._items[i] = this._items[i-1];
            }
            this._first = 0;
            this._items[this._first] = element;
        }
    }

    addBack(element: any) {
        this._count++;
        this._items[this._count] = element;
    }

    removeFront() {

    }

    removeBack() {
        const item = this._items[this._first];
        delete this._items[this._first];
        this._first++;
        return item;
    }

    peekFront() {
        if (this.isEmpty()) return undefined;

        return this._items[this._first];
    }

    peekBack() {
        return this._items[this._count];
    }

    size() {
        return this._count - this._first;
    }

    isEmpty() {
        return this.size() === 0;
    }
}
```





## 链表



### 普通链表

链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。



![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fec67b98dc4addb622ef025afeaabc~tplv-k3u1fbpfcp-watermark.image?)



在数组中，我们可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，则需要从**起点（表头**
**）开始迭代**链表直到找到所需的元素。



```typescript
class LinkedList {
    head: LNode | null;
    equalsFn: Function;
    count: number;
    constructor(fn: Function) {
        this.count = 0;
        this.equalsFn = fn;
        this.head = null;
    }

    push(element: any) {
        const node = new LNode(element);
        this.count++;

        if (this.head) {
            let current = this.head.next;
            while (current?.next) {
                current = current.next;
            }
            current!.next = element;
        } else {
            this.head = node;
        }
    }

    insert(element: any, position: number) {
        if (position >= 0 || position <= this.count) {
            if (position == 0) {
                const current = this.head;
                const insertNode = new LNode(element);
                insertNode.next = current;
                this.head = current;
                return true
            } else {
                const prev = this.getElementAt(position - 1);
                const insertNode = new LNode(element);
                const current = prev?.next;
                insertNode.next = current;
                prev?.next = insertNode;
                return true
            }
            this.count++;
        }

        return false;

    }

    getElementAt(index: number) {
        if (index >= 0 && index <= this.count) {
            let node = this.head;
            for (let i = 0; i < index && node; i++) {
                node = node.next!;
            }
            return node;
        } else {
            return undefined;
        }
    }

    remove(element: any) {
        const index = this.indexOf(element);
        if (index > -1) {
            this.removeAt(index)
            this.count--;

        }
    }

    indexOf(element: any) {
        if (!element) return -1;
        let node = this.head;
        for (let i = 0; i < this.count; i++) {
            if (node?.node === element) {
                return i
            } else {
                node = node?.next!
            }
        }

        return -1
    }

    removeAt(position: number) {
        if (position < 0 || position > this.count) return

        let node = this.head;
        for (let i = 0; i <= position; i++) {
            node = node?.next!
        }

        const next = node?.next;
        node!.next = next?.next;
    }

    isEmpty() {
        return this.count === 0;
    }

    size() {
        return this.count;
    }
}

class LNode {
    node: any;
    next: LNode | undefined;

    constructor(element: any) {
        this.node = element;
        this.next = undefined;
    }
}
```



### 双向链表

双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/667a7668a0b74258bf08e718da57eaff~tplv-k3u1fbpfcp-watermark.image?)





### 循环链表

可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a791168319747a5b424fc99d43e1f8b~tplv-k3u1fbpfcp-watermark.image?)



### 有序链表

是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性
